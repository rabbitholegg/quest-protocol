{"language":"Solidity","sources":{"contracts/QuestFactory.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.19;\r\n\r\n// Inherits\r\nimport {Initializable} from \"openzeppelin-contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport {LegacyStorage} from \"./libraries/LegacyStorage.sol\";\r\nimport {OwnableRoles} from \"solady/auth/OwnableRoles.sol\";\r\n// Implements\r\nimport {IQuestFactory} from \"./interfaces/IQuestFactory.sol\";\r\n// Leverages\r\nimport {ECDSA} from \"openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\r\nimport {LibClone} from \"solady/utils/LibClone.sol\";\r\nimport {LibString} from \"solady/utils/LibString.sol\";\r\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\r\nimport {LibZip} from \"solady/utils/LibZip.sol\";\r\n// References\r\nimport {IERC1155} from \"openzeppelin-contracts/token/ERC1155/IERC1155.sol\";\r\nimport {IQuestOwnable} from \"./interfaces/IQuestOwnable.sol\";\r\nimport {IQuest1155Ownable} from \"./interfaces/IQuest1155Ownable.sol\";\r\n\r\n/// @title QuestFactory\r\n/// @author RabbitHole.gg\r\n/// @dev This contract is used to create quests and handle claims\r\ncontract QuestFactory is Initializable, LegacyStorage, OwnableRoles, IQuestFactory {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 USING\r\n    //////////////////////////////////////////////////////////////*/\r\n    using SafeTransferLib for address;\r\n    using LibClone for address;\r\n    using LibString for string;\r\n    using LibString for uint256;\r\n    using LibString for address;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n    address public claimSignerAddress;\r\n    address public protocolFeeRecipient;\r\n    address public erc20QuestAddress;\r\n    address public erc1155QuestAddress;\r\n    mapping(string => Quest) public quests;\r\n    address private __deprecated_rabbitHoleReceiptContract; // not used\r\n    address private __deprecated_rabbitHoleTicketsContract; // not used\r\n    mapping(address => bool) private __deprecated_rewardAllowlist; // not used\r\n    uint16 public questFee;\r\n    uint256 public mintFee;\r\n    address public defaultMintFeeRecipient;\r\n    uint256 private locked;\r\n    address private __deprecated_defaultReferralFeeRecipient; // not used\r\n    uint256 private __deprecated_nftQuestFee; // not used\r\n    address private __deprecated_questNFTAddress; // not used\r\n    mapping(address => address[]) private ownerCollections;\r\n    mapping(address => NftQuestFees) private __deprecated_nftQuestFeeList; // not used\r\n    uint16 public referralFee;\r\n    address private __deprecated_sablierV2LockupLinearAddress; // not used\r\n    mapping(address => address) private __deprecated_mintFeeRecipientList; // not used\r\n    // insert new vars here at the end to keep the storage layout the same\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    // solhint-disable-next-line func-visibility\r\n    constructor() initializer {}\r\n\r\n    function initialize(\r\n        address claimSignerAddress_,\r\n        address protocolFeeRecipient_,\r\n        address erc20QuestAddress_,\r\n        address payable erc1155QuestAddress_,\r\n        address ownerAddress_,\r\n        uint256,\r\n        uint16 referralFee_,\r\n        uint256 mintFee_\r\n    ) external initializer {\r\n        _initializeOwner(ownerAddress_);\r\n        questFee = 2000; // in BIPS\r\n        locked = 1;\r\n        claimSignerAddress = claimSignerAddress_;\r\n        protocolFeeRecipient = protocolFeeRecipient_;\r\n        erc20QuestAddress = erc20QuestAddress_;\r\n        erc1155QuestAddress = erc1155QuestAddress_;\r\n        referralFee = referralFee_;\r\n        mintFee = mintFee_;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               MODIFIERS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    modifier checkQuest(string memory questId_) {\r\n        Quest storage currentQuest = quests[questId_];\r\n        if (currentQuest.questAddress != address(0)) revert QuestIdUsed();\r\n        if (erc20QuestAddress == address(0)) revert Erc20QuestAddressNotSet();\r\n        _;\r\n    }\r\n\r\n    modifier claimChecks(ClaimData memory claimData_) {\r\n        Quest storage currentQuest = quests[claimData_.questId];\r\n\r\n        if (currentQuest.numberMinted + 1 > currentQuest.totalParticipants) revert OverMaxAllowedToMint();\r\n        if (currentQuest.addressMinted[claimData_.claimer]) revert AddressAlreadyMinted();\r\n        if (recoverSigner(claimData_.hashBytes, claimData_.signature) != claimSignerAddress) revert AddressNotSigned();\r\n        _;\r\n    }\r\n\r\n    /// @dev ReentrancyGuard modifier from solmate, copied here because it was added after storage layout was finalized on first deploy\r\n    /// @dev from https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol\r\n    modifier nonReentrant() virtual {\r\n        if (locked != 1) revert Reentrancy();\r\n        locked = 2;\r\n        _;\r\n        locked = 1;\r\n    }\r\n\r\n    modifier nonZeroAddress(address address_) {\r\n        if (address_ == address(0)) revert ZeroAddressNotAllowed();\r\n        _;\r\n    }\r\n\r\n    modifier sufficientMintFee() {\r\n        if (msg.value < mintFee) revert InvalidMintFee();\r\n        _;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            EXTERNAL UPDATE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 CREATE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Create an erc20 quest and start it at the same time. The function will transfer the reward amount to the quest contract\r\n    /// @param txHashChainId_ The chain id of the chain the txHash is on\r\n    /// @param rewardTokenAddress_ The contract address of the reward token\r\n    /// @param endTime_ The end time of the quest\r\n    /// @param startTime_ The start time of the quest\r\n    /// @param totalParticipants_ The total amount of participants (accounts) the quest will have\r\n    /// @param rewardAmount_ The reward amount for an erc20 quest\r\n    /// @param questId_ The id of the quest\r\n    /// @param actionType_ The action type for the quest\r\n    /// @param questName_ The name of the quest\r\n    /// @return address the quest contract address\r\n    function createERC20Quest(\r\n        uint32 txHashChainId_,\r\n        address rewardTokenAddress_,\r\n        uint256 endTime_,\r\n        uint256 startTime_,\r\n        uint256 totalParticipants_,\r\n        uint256 rewardAmount_,\r\n        string memory questId_,\r\n        string memory actionType_,\r\n        string memory questName_,\r\n        string memory projectName_\r\n    ) external checkQuest(questId_) returns (address) {\r\n        return createERC20QuestInternal(\r\n            ERC20QuestData(\r\n                txHashChainId_,\r\n                rewardTokenAddress_,\r\n                endTime_,\r\n                startTime_,\r\n                totalParticipants_,\r\n                rewardAmount_,\r\n                questId_,\r\n                actionType_,\r\n                questName_,\r\n                \"erc20\",\r\n                projectName_\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @dev Create an erc1155 quest and start it at the same time. The function will transfer the reward amount to the quest contract\r\n    /// @param txHashChainId_ The chain id of the chain the txHash is on\r\n    /// @param rewardTokenAddress_ The contract address of the reward token\r\n    /// @param endTime_ The end time of the quest\r\n    /// @param startTime_ The start time of the quest\r\n    /// @param totalParticipants_ The total amount of participants (accounts) the quest will have\r\n    /// @param tokenId_ The reward token id of the erc1155 at rewardTokenAddress_\r\n    /// @param questId_ The id of the quest\r\n    /// @param actionType_ The action type for the quest\r\n    /// @param questName_ The name of the quest\r\n    /// @return address the quest contract address\r\n    function createERC1155Quest(\r\n        uint32 txHashChainId_,\r\n        address rewardTokenAddress_,\r\n        uint256 endTime_,\r\n        uint256 startTime_,\r\n        uint256 totalParticipants_,\r\n        uint256 tokenId_,\r\n        string memory questId_,\r\n        string memory actionType_,\r\n        string memory questName_,\r\n        string memory projectName_\r\n    ) external payable nonReentrant returns (address) {\r\n        return createERC1155QuestInternal(\r\n            ERC1155QuestData(\r\n                txHashChainId_,\r\n                rewardTokenAddress_,\r\n                endTime_,\r\n                startTime_,\r\n                totalParticipants_,\r\n                tokenId_,\r\n                questId_,\r\n                actionType_,\r\n                questName_,\r\n                projectName_\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @notice Deprecated\r\n    function createERC1155Quest(\r\n        address rewardTokenAddress_,\r\n        uint256 endTime_,\r\n        uint256 startTime_,\r\n        uint256 totalParticipants_,\r\n        uint256 tokenId_,\r\n        string memory questId_,\r\n        string memory actionType_,\r\n        string memory questName_,\r\n        string memory projectName_\r\n    ) external payable nonReentrant returns (address) {\r\n        return createERC1155QuestInternal(\r\n            ERC1155QuestData(\r\n                0,\r\n                rewardTokenAddress_,\r\n                endTime_,\r\n                startTime_,\r\n                totalParticipants_,\r\n                tokenId_,\r\n                questId_,\r\n                actionType_,\r\n                questName_,\r\n                projectName_\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @notice Deprecated\r\n    function create1155QuestAndQueue(\r\n        address rewardTokenAddress_,\r\n        uint256 endTime_,\r\n        uint256 startTime_,\r\n        uint256 totalParticipants_,\r\n        uint256 tokenId_,\r\n        string memory questId_,\r\n        string memory\r\n    ) external payable nonReentrant returns (address) {\r\n        return createERC1155QuestInternal(\r\n            ERC1155QuestData(\r\n                0,\r\n                rewardTokenAddress_,\r\n                endTime_,\r\n                startTime_,\r\n                totalParticipants_,\r\n                tokenId_,\r\n                questId_,\r\n                \"\",\r\n                \"\",\r\n                \"\"\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @notice Deprecated\r\n    function createERC20Quest(\r\n        address rewardTokenAddress_,\r\n        uint256 endTime_,\r\n        uint256 startTime_,\r\n        uint256 totalParticipants_,\r\n        uint256 rewardAmount_,\r\n        string memory questId_,\r\n        string memory actionType_,\r\n        string memory questName_\r\n    ) external checkQuest(questId_) returns (address) {\r\n        return createERC20QuestInternal(\r\n            ERC20QuestData(\r\n                0,\r\n                rewardTokenAddress_,\r\n                endTime_,\r\n                startTime_,\r\n                totalParticipants_,\r\n                rewardAmount_,\r\n                questId_,\r\n                actionType_,\r\n                questName_,\r\n                \"erc20\",\r\n                \"\"\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @notice Deprecated\r\n    function createQuestAndQueue(\r\n        address rewardTokenAddress_,\r\n        uint256 endTime_,\r\n        uint256 startTime_,\r\n        uint256 totalParticipants_,\r\n        uint256 rewardAmount_,\r\n        string memory questId_,\r\n        string memory,\r\n        uint256\r\n    ) external checkQuest(questId_) returns (address) {\r\n        return createERC20QuestInternal(\r\n            ERC20QuestData(\r\n                0,\r\n                rewardTokenAddress_,\r\n                endTime_,\r\n                startTime_,\r\n                totalParticipants_,\r\n                rewardAmount_,\r\n                questId_,\r\n                \"\",\r\n                \"\",\r\n                \"erc20\",\r\n                \"\"\r\n            )\r\n        );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 CLAIM\r\n    //////////////////////////////////////////////////////////////*/\r\n    /// @dev Claim rewards for a quest\r\n    /// @param compressedData_ The claim data in abi encoded bytes, compressed with cdCompress from solady LibZip\r\n    function claimCompressed(bytes calldata compressedData_) external payable {\r\n        _claimCompressed(compressedData_, msg.sender);\r\n    }\r\n\r\n    function claimCompressedRef(bytes calldata compressedData_, address claimer) external payable {\r\n        _claimCompressed(compressedData_, claimer);\r\n    }\r\n\r\n    /// @dev Claim rewards for a quest\r\n    /// @param compressedData_ The claim data in abi encoded bytes, compressed with cdCompress from solady LibZip\r\n    /// @param claimer The address of the claimer - where rewards are sent\r\n    function _claimCompressed(bytes calldata compressedData_, address claimer) internal {\r\n        bytes memory data_ = LibZip.cdDecompress(compressedData_);\r\n\r\n        (\r\n            bytes32 txHash_,\r\n            bytes32 r_,\r\n            bytes32 vs_,\r\n            address ref_,\r\n            bytes16 questid_,\r\n            uint32 txHashChainId_\r\n        ) = abi.decode(\r\n            data_,\r\n            (bytes32, bytes32, bytes32, address, bytes16, uint32)\r\n        );\r\n\r\n        string memory questIdString_ = bytes16ToUUID(questid_);\r\n        Quest storage quest_ = quests[questIdString_];\r\n\r\n        string memory jsonData_ = _buildJsonString(txHash_, txHashChainId_, quest_.actionType);\r\n        bytes memory claimData_ = abi.encode(claimer, ref_, questIdString_, jsonData_);\r\n\r\n        // Since `vs_` includes `s` and the bit for `v`, we can extract `s` by masking out the `v` bit.\r\n        bytes32 s = vs_ & bytes32(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n        // Now extract the `v` by shifting `vs_` right by 255 bits and casting to a uint8\r\n        uint8 v = uint8((uint256(vs_) >> 255));\r\n\r\n        // If `v` is less than 27 (which means it's either 0, 1, or invalid), add 27 to push it into range (27, 28)\r\n        // Note that if `v` was neither 0 nor 1, this will push it out of range, and the signature will be invalid\r\n        if (v < 27) v += 27;\r\n\r\n        _claimOptimized(abi.encodePacked(r_, s, v), claimData_);\r\n    }\r\n\r\n    /// @notice External use is deprecated\r\n    /// @dev Claim rewards for a quest\r\n    /// @param -DEPRECATED- signature_ The signature of the claim data\r\n    /// @param -DEPRECATED- data_ The claim data in abi encoded bytes\r\n    function claimOptimized(bytes calldata, bytes calldata) external payable {\r\n        revert Deprecated();\r\n    }\r\n\r\n    /// @dev Claim rewards for a quest\r\n    /// @param signature_ The signature of the claim data\r\n    /// @param data_ The claim data in abi encoded bytes\r\n    function _claimOptimized(\r\n        bytes memory signature_,\r\n        bytes memory data_\r\n    ) internal {\r\n        (\r\n            address claimer_,\r\n            address ref_,\r\n            string memory questId_,\r\n            string memory jsonData_\r\n        ) = abi.decode(\r\n            data_,\r\n            (address, address, string, string)\r\n        );\r\n        Quest storage quest = quests[questId_];\r\n\r\n        uint256 numberMintedPlusOne_ = quest.numberMinted + 1;\r\n        address rewardToken_ = IQuestOwnable(quest.questAddress).rewardToken();\r\n        uint256 rewardAmountOrTokenId;\r\n\r\n        if (recoverSigner(keccak256(data_), signature_) != claimSignerAddress) revert AddressNotSigned();\r\n        if (msg.value < mintFee) revert InvalidMintFee();\r\n        if (quest.addressMinted[claimer_]) revert AddressAlreadyMinted();\r\n        if (numberMintedPlusOne_ > quest.totalParticipants) revert OverMaxAllowedToMint();\r\n\r\n        quest.addressMinted[claimer_] = true;\r\n        quest.numberMinted = numberMintedPlusOne_;\r\n        (bool success_, ) = quest.questAddress.call{value: msg.value}(abi.encodeWithSignature(\"claimFromFactory(address,address)\", claimer_, ref_));\r\n        if (!success_) revert ClaimFailed();\r\n\r\n        emit QuestClaimedData(claimer_, quest.questAddress, jsonData_);\r\n        if (quest.questType.eq(\"erc1155\")) {\r\n            rewardAmountOrTokenId = IQuest1155Ownable(quest.questAddress).tokenId();\r\n            emit Quest1155Claimed(claimer_, quest.questAddress, questId_, rewardToken_, rewardAmountOrTokenId);\r\n        } else {\r\n            rewardAmountOrTokenId = IQuestOwnable(quest.questAddress).rewardAmountInWei();\r\n            emit QuestClaimed(claimer_, quest.questAddress, questId_, rewardToken_, rewardAmountOrTokenId);\r\n        }\r\n        if(ref_ != address(0)){\r\n            emit QuestClaimedReferred(claimer_, quest.questAddress, questId_, rewardToken_, rewardAmountOrTokenId, ref_, 3333, mintFee);\r\n            emit MintFeePaid(questId_, address(0), 0, address(0), 0, ref_, mintFee / 3);\r\n        }\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                  SET\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev set the claim signer address\r\n    /// @param claimSignerAddress_ The address of the claim signer\r\n    function setClaimSignerAddress(address claimSignerAddress_) external onlyOwner {\r\n        claimSignerAddress = claimSignerAddress_;\r\n    }\r\n\r\n    /// @dev set erc1155QuestAddress\r\n    /// @param erc1155QuestAddress_ The address of the erc1155 quest\r\n    function setErc1155QuestAddress(address erc1155QuestAddress_) external onlyOwner {\r\n        erc1155QuestAddress = erc1155QuestAddress_;\r\n    }\r\n\r\n    /// @dev set erc20QuestAddress\r\n    /// @param erc20QuestAddress_ The address of the erc20 quest\r\n    function setErc20QuestAddress(address erc20QuestAddress_) external onlyOwner {\r\n        erc20QuestAddress = erc20QuestAddress_;\r\n    }\r\n\r\n    /// @dev set the mint fee\r\n    /// @notice the mint fee in ether\r\n    /// @param mintFee_ The mint fee value\r\n    function setMintFee(uint256 mintFee_) external onlyOwner {\r\n        mintFee = mintFee_;\r\n        emit MintFeeSet(mintFee_);\r\n    }\r\n\r\n    /// @dev set the protocol fee recipient\r\n    /// @param protocolFeeRecipient_ The address of the protocol fee recipient\r\n    function setProtocolFeeRecipient(address protocolFeeRecipient_) external onlyOwner {\r\n        if (protocolFeeRecipient_ == address(0)) revert AddressZeroNotAllowed();\r\n        protocolFeeRecipient = protocolFeeRecipient_;\r\n    }\r\n\r\n    /// @dev set the quest fee\r\n    /// @notice the quest fee should be in Basis Point units\r\n    /// @param questFee_ The quest fee value\r\n    function setQuestFee(uint16 questFee_) external onlyOwner {\r\n        if (questFee_ > 10_000) revert QuestFeeTooHigh();\r\n        questFee = questFee_;\r\n    }\r\n\r\n    /// @dev set the referral fee\r\n    /// @param referralFee_ The value of the referralFee\r\n    function setReferralFee(uint16 referralFee_) external onlyOwner {\r\n        if (referralFee_ > 10_000) revert ReferralFeeTooHigh();\r\n        referralFee = referralFee_;\r\n        emit ReferralFeeSet(referralFee_);\r\n    }\r\n\r\n    /// @dev set the mintFeeRecipient\r\n    /// @param mintFeeRecipient_ The address of the mint fee recipient\r\n    function setDefaultMintFeeRecipient(address mintFeeRecipient_) external onlyOwner {\r\n        if (mintFeeRecipient_ == address(0)) revert AddressZeroNotAllowed();\r\n        defaultMintFeeRecipient = mintFeeRecipient_;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             EXTERNAL VIEW\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice This function name is a bit of a misnomer - gets whether an address has claimed a quest yet.\r\n    /// @dev return status of whether an address has claimed a quest\r\n    /// @param questId_ The id of the quest\r\n    /// @param address_ The address to check\r\n    /// @return claimed status\r\n    function getAddressMinted(string memory questId_, address address_) external view returns (bool) {\r\n        return quests[questId_].addressMinted[address_];\r\n    }\r\n\r\n    /// @dev return the number of quest claims\r\n    /// @param questId_ The id of the quest\r\n    /// @return uint Total quests claimed\r\n    function getNumberMinted(string memory questId_) external view returns (uint256) {\r\n        return quests[questId_].numberMinted;\r\n    }\r\n\r\n    /// @dev return extended quest data for a questId\r\n    /// @param questId_ The id of the quest\r\n    function questData(string memory questId_) external view returns (QuestData memory) {\r\n        Quest storage thisQuest = quests[questId_];\r\n        IQuestOwnable questContract = IQuestOwnable(thisQuest.questAddress);\r\n        uint256 rewardAmountOrTokenId;\r\n        uint16 erc20QuestFee;\r\n\r\n        if (thisQuest.questType.eq(\"erc1155\")) {\r\n            rewardAmountOrTokenId = IQuest1155Ownable(thisQuest.questAddress).tokenId();\r\n        } else {\r\n            rewardAmountOrTokenId = questContract.rewardAmountInWei();\r\n            erc20QuestFee = questContract.questFee();\r\n        }\r\n\r\n        QuestData memory data = QuestData(\r\n            thisQuest.questAddress,\r\n            questContract.rewardToken(),\r\n            questContract.queued(),\r\n            erc20QuestFee,\r\n            questContract.startTime(),\r\n            questContract.endTime(),\r\n            questContract.totalParticipants(),\r\n            thisQuest.numberMinted,\r\n            thisQuest.numberMinted,\r\n            rewardAmountOrTokenId,\r\n            questContract.hasWithdrawn()\r\n        );\r\n\r\n        return data;\r\n    }\r\n\r\n    /// @param questId_ The id of the quest\r\n    function questJsonData(string memory questId_) external view returns (QuestJsonData memory) {\r\n        Quest storage thisQuest = quests[questId_];\r\n\r\n        QuestJsonData memory data = QuestJsonData(\r\n            thisQuest.actionType,\r\n            thisQuest.questName,\r\n            thisQuest.txHashChainId\r\n        );\r\n\r\n        return data;\r\n    }\r\n\r\n    /// @dev return data in the quest struct for a questId\r\n    /// @param questId_ The id of the quest\r\n    function questInfo(string memory questId_) external view returns (address, uint256, uint256) {\r\n        Quest storage currentQuest = quests[questId_];\r\n        return (currentQuest.questAddress, currentQuest.totalParticipants, currentQuest.numberMinted);\r\n    }\r\n\r\n    /// @dev recover the signer from a hash and signature\r\n    /// @param hash_ The hash of the message\r\n    /// @param signature_ The signature of the hash\r\n    function recoverSigner(bytes32 hash_, bytes memory signature_) public view returns (address) {\r\n        return ECDSA.recover(ECDSA.toEthSignedMessageHash(hash_), signature_);\r\n    }\r\n\r\n    function withdrawCallback(string calldata questId_, address protocolFeeRecipient_, uint protocolPayout_, address mintFeeRecipient_, uint mintPayout) external {\r\n        Quest storage quest = quests[questId_];\r\n        if(msg.sender != quest.questAddress) revert QuestAddressMismatch();\r\n\r\n        emit MintFeePaid(questId_, protocolFeeRecipient_, protocolPayout_, mintFeeRecipient_, mintPayout, address(0), 0);\r\n    }\r\n\r\n    function getQuestName(string calldata questId_) external view returns (string memory) {\r\n        return quests[questId_].questName;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            INTERNAL UPDATE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev claim rewards for a quest with a referral address\r\n    /// @param claimData_ The claim data struct\r\n    function claim1155RewardsRef(ClaimData memory claimData_) private\r\n        nonReentrant\r\n        sufficientMintFee\r\n        claimChecks(claimData_)\r\n    {\r\n        Quest storage currentQuest = quests[claimData_.questId];\r\n        IQuest1155Ownable questContract_ = IQuest1155Ownable(currentQuest.questAddress);\r\n        if (!questContract_.queued()) revert QuestNotQueued();\r\n        if (block.timestamp < questContract_.startTime()) revert QuestNotStarted();\r\n        if (block.timestamp > questContract_.endTime()) revert QuestEnded();\r\n\r\n        currentQuest.addressMinted[claimData_.claimer] = true;\r\n        ++currentQuest.numberMinted;\r\n        questContract_.singleClaim(claimData_.claimer);\r\n\r\n        if (mintFee > 0) {\r\n            string memory newJson = processMintFee(claimData_.ref, currentQuest.questCreator, claimData_.questId);\r\n            if (bytes(claimData_.extraData).length > 0){\r\n                claimData_.extraData = claimData_.extraData.slice(0, bytes(claimData_.extraData).length -1).concat(newJson);\r\n            }\r\n        }\r\n\r\n        emit QuestClaimedData(\r\n            claimData_.claimer,\r\n            currentQuest.questAddress,\r\n            claimData_.extraData\r\n        );\r\n\r\n        emit Quest1155Claimed(\r\n            claimData_.claimer, currentQuest.questAddress, claimData_.questId, questContract_.rewardToken(), questContract_.tokenId()\r\n        );\r\n\r\n        if (claimData_.ref != address(0)) {\r\n            emit QuestClaimedReferred(\r\n                claimData_.claimer,\r\n                currentQuest.questAddress,\r\n                claimData_.questId,\r\n                questContract_.rewardToken(),\r\n                questContract_.tokenId(),\r\n                claimData_.ref,\r\n                3333, //referralFee,\r\n                mintFee\r\n                );\r\n        }\r\n    }\r\n\r\n    /// @dev claim rewards with a referral address\r\n    /// @param claimData_ The claim data struct\r\n    function claimRewardsRef(ClaimData memory claimData_) private\r\n        nonReentrant\r\n        sufficientMintFee\r\n        claimChecks(claimData_)\r\n    {\r\n        Quest storage currentQuest = quests[claimData_.questId];\r\n        IQuestOwnable questContract_ = IQuestOwnable(currentQuest.questAddress);\r\n        if (!questContract_.queued()) revert QuestNotQueued();\r\n        if (block.timestamp < questContract_.startTime()) revert QuestNotStarted();\r\n        if (block.timestamp > questContract_.endTime()) revert QuestEnded();\r\n\r\n        currentQuest.addressMinted[claimData_.claimer] = true;\r\n        ++currentQuest.numberMinted;\r\n        questContract_.singleClaim(claimData_.claimer);\r\n\r\n        if (mintFee > 0) {\r\n            string memory newJson = processMintFee(claimData_.ref, currentQuest.questCreator, claimData_.questId);\r\n            if (bytes(claimData_.extraData).length > 0){\r\n                claimData_.extraData = claimData_.extraData.slice(0, bytes(claimData_.extraData).length -1).concat(newJson);\r\n            }\r\n        }\r\n\r\n        emit QuestClaimedData(\r\n            claimData_.claimer,\r\n            currentQuest.questAddress,\r\n            claimData_.extraData\r\n        );\r\n\r\n        emit QuestClaimed(\r\n            claimData_.claimer,\r\n            currentQuest.questAddress,\r\n            claimData_.questId,\r\n            questContract_.rewardToken(),\r\n            questContract_.rewardAmountInWei()\r\n        );\r\n\r\n        if (claimData_.ref != address(0)) {\r\n            emit QuestClaimedReferred(\r\n                claimData_.claimer,\r\n                currentQuest.questAddress,\r\n                claimData_.questId,\r\n                questContract_.rewardToken(),\r\n                questContract_.rewardAmountInWei(),\r\n                claimData_.ref,\r\n                3333, //referralFee,\r\n                mintFee\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Internal function to create an erc1155 quest\r\n    /// @param data_ The erc20 quest data struct\r\n    function createERC1155QuestInternal(ERC1155QuestData memory data_) internal returns (address) {\r\n        Quest storage currentQuest = quests[data_.questId];\r\n\r\n        if (currentQuest.questAddress != address(0)) revert QuestIdUsed();\r\n\r\n        address payable newQuest =\r\n            payable(erc1155QuestAddress.cloneDeterministic(keccak256(abi.encodePacked(msg.sender, block.chainid, block.timestamp))));\r\n        currentQuest.questAddress = address(newQuest);\r\n        currentQuest.totalParticipants = data_.totalParticipants;\r\n        currentQuest.questType = \"erc1155\";\r\n        currentQuest.questCreator = msg.sender;\r\n        currentQuest.actionType = data_.actionType;\r\n        currentQuest.questName = data_.questName;\r\n        currentQuest.txHashChainId = data_.txHashChainId;\r\n        IQuest1155Ownable questContract = IQuest1155Ownable(newQuest);\r\n\r\n        questContract.initialize(\r\n            data_.rewardTokenAddress,\r\n            data_.endTime,\r\n            data_.startTime,\r\n            data_.totalParticipants,\r\n            data_.tokenId,\r\n            protocolFeeRecipient,\r\n            data_.questId\r\n        );\r\n\r\n        IERC1155(data_.rewardTokenAddress).safeTransferFrom(msg.sender, newQuest, data_.tokenId, data_.totalParticipants, \"0x00\");\r\n        questContract.queue();\r\n        questContract.transferOwnership(msg.sender);\r\n\r\n        emit QuestCreated(\r\n            msg.sender,\r\n            address(newQuest),\r\n            data_.projectName,\r\n            data_.questName,\r\n            data_.questId,\r\n            currentQuest.questType,\r\n            data_.actionType,\r\n            data_.txHashChainId,\r\n            data_.rewardTokenAddress,\r\n            data_.endTime,\r\n            data_.startTime,\r\n            data_.totalParticipants,\r\n            data_.tokenId\r\n        );\r\n\r\n        return newQuest;\r\n    }\r\n\r\n    /// @dev Internal function to create an erc20 quest\r\n    /// @param data_ The erc20 quest data struct\r\n    function createERC20QuestInternal(ERC20QuestData memory data_) internal returns (address) {\r\n        Quest storage currentQuest = quests[data_.questId];\r\n        address newQuest = erc20QuestAddress.cloneDeterministic(keccak256(abi.encodePacked(msg.sender, block.chainid, block.timestamp)));\r\n\r\n        currentQuest.questAddress = address(newQuest);\r\n        currentQuest.totalParticipants = data_.totalParticipants;\r\n        currentQuest.questCreator = msg.sender;\r\n        currentQuest.questType = data_.questType;\r\n        currentQuest.actionType = data_.actionType;\r\n        currentQuest.questName = data_.questName;\r\n        currentQuest.txHashChainId = data_.txHashChainId;\r\n\r\n        emit QuestCreated(\r\n            msg.sender,\r\n            address(newQuest),\r\n            data_.projectName,\r\n            data_.questName,\r\n            data_.questId,\r\n            currentQuest.questType,\r\n            data_.actionType,\r\n            data_.txHashChainId,\r\n            data_.rewardTokenAddress,\r\n            data_.endTime,\r\n            data_.startTime,\r\n            data_.totalParticipants,\r\n            data_.rewardAmount\r\n        );\r\n\r\n        IQuestOwnable(newQuest).initialize(\r\n            data_.rewardTokenAddress,\r\n            data_.endTime,\r\n            data_.startTime,\r\n            data_.totalParticipants,\r\n            data_.rewardAmount,\r\n            data_.questId,\r\n            questFee,\r\n            protocolFeeRecipient\r\n        );\r\n\r\n        transferTokensAndOwnership(newQuest, data_.rewardTokenAddress);\r\n        return newQuest;\r\n    }\r\n\r\n    function processMintFee(address ref_, address mintFeeRecipient_, string memory questId_) private returns (string memory) {\r\n        returnChange();\r\n        uint256 cachedMintFee = mintFee;\r\n        uint256 oneThirdMintfee = cachedMintFee / 3;\r\n        uint256 protocolPayout;\r\n        uint256 mintPayout;\r\n        uint256 referrerPayout;\r\n\r\n        if(ref_ == address(0)){\r\n            protocolPayout = oneThirdMintfee * 2;\r\n            mintPayout = oneThirdMintfee;\r\n        } else {\r\n            protocolPayout = oneThirdMintfee;\r\n            mintPayout = oneThirdMintfee;\r\n            referrerPayout = oneThirdMintfee;\r\n        }\r\n\r\n        protocolFeeRecipient.safeTransferETH(protocolPayout);\r\n        mintFeeRecipient_.safeTransferETH(mintPayout);\r\n        if(referrerPayout != 0) ref_.safeTransferETH(referrerPayout);\r\n\r\n        emit MintFeePaid(questId_, protocolFeeRecipient, protocolPayout, mintFeeRecipient_, mintPayout, ref_, referrerPayout);\r\n\r\n        return string(abi.encodePacked(\r\n            ', \"claimFee\": \"', cachedMintFee.toString(),\r\n            '\", \"claimFeePayouts\": [{\"name\": \"protocolPayout\", \"address\": \"', protocolFeeRecipient.toHexString(),\r\n            '\", \"value\": \"', protocolPayout.toString(),\r\n            '\"}, {\"name\": \"mintPayout\", \"address\": \"', mintFeeRecipient_.toHexString(),\r\n            '\", \"value\": \"', mintPayout.toString(),\r\n            '\"}, {\"name\": \"referrerPayout\", \"address\": \"', ref_.toHexString(),\r\n            '\", \"value\": \"', referrerPayout.toString(), '\"}]}'\r\n        ));\r\n    }\r\n\r\n    // Refund any excess payment\r\n    function returnChange() private {\r\n        uint256 change = msg.value - mintFee;\r\n        if (change > 0) {\r\n            msg.sender.safeTransferETH(change);\r\n        }\r\n    }\r\n\r\n    /// @dev Transfer the total transfer amount to the quest contract\r\n    /// @dev Contract must be approved to transfer first\r\n    /// @param newQuest_ The address of the new quest\r\n    /// @param rewardTokenAddress_ The contract address of the reward token\r\n    function transferTokensAndOwnership(address newQuest_, address rewardTokenAddress_) internal {\r\n        address sender = msg.sender;\r\n        IQuestOwnable questContract = IQuestOwnable(newQuest_);\r\n        rewardTokenAddress_.safeTransferFrom(sender, newQuest_, questContract.totalTransferAmount());\r\n        questContract.transferOwnership(sender);\r\n    }\r\n\r\n    /// @dev Build the expected json string for a quest\r\n    /// @param txHash The transaction hash\r\n    /// @param txHashChainId The chain id of the transaction hash\r\n    /// @param actionType The action type for the quest\r\n    /// @param -deprecated- The name of the quest\r\n    /// @return string The json string\r\n    function buildJsonString(\r\n        bytes32 txHash,\r\n        uint32 txHashChainId,\r\n        string memory actionType,\r\n        string memory // questName - not used\r\n    ) external pure returns (string memory) {\r\n        return _buildJsonString(txHash, txHashChainId, actionType);\r\n    }\r\n\r\n    /// @dev Build the expected json string for a quest\r\n    /// @param txHash The transaction hash\r\n    /// @param txHashChainId The chain id of the transaction hash\r\n    /// @param actionType The action type for the quest\r\n    /// @return string The json string\r\n    function _buildJsonString(\r\n        bytes32 txHash,\r\n        uint32 txHashChainId,\r\n        string memory actionType\r\n    ) internal pure returns (string memory) {\r\n        // {\r\n        //     actionTxHashes: [\"actionTxHash1\"],\r\n        //     actionNetworkChainIds: [\"chainId1\"],\r\n        //     actionType: \"mint\"\r\n        // }\r\n        return string(abi.encodePacked(\r\n            '{\"actionTxHashes\":[\"', uint256(txHash).toHexString(32),\r\n            '\"],\"actionNetworkChainIds\":[', uint256(txHashChainId).toString(),\r\n            '],\"actionType\":\"', actionType, '\"}'\r\n        ));\r\n    }\r\n\r\n    /// @dev Convert bytes16 to a UUID string e.g. 550e8400-e29b-41d4-a716-446655440000\r\n    /// @param data The bytes16 data e.g. 0x550e8400e29b41d4a716446655440000\r\n    function bytes16ToUUID(bytes16 data) internal pure returns (string memory) {\r\n        bytes memory hexChars = \"0123456789abcdef\";\r\n        bytes memory uuid = new bytes(36); // UUID length with hyphens\r\n\r\n        uint256 j = 0; // Position in uuid\r\n        for (uint256 i = 0; i < 16; i++) {\r\n            // Insert hyphens at the appropriate positions (after 4, 6, 8, 10 bytes)\r\n            if (i == 4 || i == 6 || i == 8 || i == 10) {\r\n                uuid[j++] = '-';\r\n            }\r\n\r\n            uuid[j++] = hexChars[uint8(data[i] >> 4)];\r\n            uuid[j++] = hexChars[uint8(data[i] & 0x0F)];\r\n        }\r\n\r\n        return string(uuid);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                DEFAULTS\r\n    //////////////////////////////////////////////////////////////*/\r\n    // Receive function to receive ETH\r\n    receive() external payable {}\r\n\r\n    // Fallback function to receive ETH when other functions are not available\r\n    fallback() external payable {}\r\n}"},"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"},"contracts/libraries/LegacyStorage.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\nabstract contract LegacyStorage {\r\n    struct RoleData {\r\n        mapping(address => bool) members;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n    address private _owner;\r\n    uint256[49] private __gap1;\r\n    uint256[50] private __gap2;\r\n    mapping(bytes32 => RoleData) private _roles;\r\n    uint256[49] private __gap3;\r\n}\r\n"},"lib/solady/src/auth/OwnableRoles.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/// @notice Simple single owner and multiroles authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\n/// for compatibility, the nomenclature for the 2-step ownership handover and roles\n/// may be unique to this codebase.\nabstract contract OwnableRoles is Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The `user`'s roles is updated to `roles`.\n    /// Each bit of `roles` represents whether the role is set.\n    event RolesUpdated(address indexed user, uint256 indexed roles);\n\n    /// @dev `keccak256(bytes(\"RolesUpdated(address,uint256)\"))`.\n    uint256 private constant _ROLES_UPDATED_EVENT_SIGNATURE =\n        0x715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The role slot of `user` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _ROLE_SLOT_SEED))\n    ///     let roleSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// This automatically ignores the upper bits of the `user` in case\n    /// they are not clean, as well as keep the `keccak256` under 32-bytes.\n    ///\n    /// Note: This is equivalent to `uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))`.\n    uint256 private constant _ROLE_SLOT_SEED = 0x8b78c6d8;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Overwrite the roles directly without authorization guard.\n    function _setRoles(address user, uint256 roles) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, user)\n            // Store the new value.\n            sstore(keccak256(0x0c, 0x20), roles)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), roles)\n        }\n    }\n\n    /// @dev Updates the roles directly without authorization guard.\n    /// If `on` is true, each set bit of `roles` will be turned on,\n    /// otherwise, each set bit of `roles` will be turned off.\n    function _updateRoles(address user, uint256 roles, bool on) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, user)\n            let roleSlot := keccak256(0x0c, 0x20)\n            // Load the current value.\n            let current := sload(roleSlot)\n            // Compute the updated roles if `on` is true.\n            let updated := or(current, roles)\n            // Compute the updated roles if `on` is false.\n            // Use `and` to compute the intersection of `current` and `roles`,\n            // `xor` it with `current` to flip the bits in the intersection.\n            if iszero(on) { updated := xor(current, and(current, roles)) }\n            // Then, store the new value.\n            sstore(roleSlot, updated)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), updated)\n        }\n    }\n\n    /// @dev Grants the roles directly without authorization guard.\n    /// Each bit of `roles` represents the role to turn on.\n    function _grantRoles(address user, uint256 roles) internal virtual {\n        _updateRoles(user, roles, true);\n    }\n\n    /// @dev Removes the roles directly without authorization guard.\n    /// Each bit of `roles` represents the role to turn off.\n    function _removeRoles(address user, uint256 roles) internal virtual {\n        _updateRoles(user, roles, false);\n    }\n\n    /// @dev Throws if the sender does not have any of the `roles`.\n    function _checkRoles(uint256 roles) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the role slot.\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, caller())\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner,\n    /// and does not have any of the `roles`.\n    /// Checks for ownership first, then lazily checks for roles.\n    function _checkOwnerOrRoles(uint256 roles) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner.\n            // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\n            if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\n                // Compute the role slot.\n                mstore(0x0c, _ROLE_SLOT_SEED)\n                mstore(0x00, caller())\n                // Load the stored value, and if the `and` intersection\n                // of the value and `roles` is zero, revert.\n                if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Throws if the sender does not have any of the `roles`,\n    /// and is not the owner.\n    /// Checks for roles first, then lazily checks for ownership.\n    function _checkRolesOrOwner(uint256 roles) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the role slot.\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, caller())\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\n                // If the caller is not the stored owner.\n                // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\n                if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function to return a `roles` bitmap from an array of `ordinals`.\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\n    /// Not recommended to be called on-chain.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _rolesFromOrdinals(uint8[] memory ordinals) internal pure returns (uint256 roles) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let i := shl(5, mload(ordinals)) } i { i := sub(i, 0x20) } {\n                // We don't need to mask the values of `ordinals`, as Solidity\n                // cleans dirty upper bits when storing variables into memory.\n                roles := or(shl(mload(add(ordinals, i)), 1), roles)\n            }\n        }\n    }\n\n    /// @dev Convenience function to return an array of `ordinals` from the `roles` bitmap.\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\n    /// Not recommended to be called on-chain.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ordinalsFromRoles(uint256 roles) internal pure returns (uint8[] memory ordinals) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the pointer to the free memory.\n            ordinals := mload(0x40)\n            let ptr := add(ordinals, 0x20)\n            let o := 0\n            // The absence of lookup tables, De Bruijn, etc., here is intentional for\n            // smaller bytecode, as this function is not meant to be called on-chain.\n            for { let t := roles } 1 {} {\n                mstore(ptr, o)\n                // `shr` 5 is equivalent to multiplying by 0x20.\n                // Push back into the ordinals array if the bit is set.\n                ptr := add(ptr, shl(5, and(t, 1)))\n                o := add(o, 1)\n                t := shr(o, roles)\n                if iszero(t) { break }\n            }\n            // Store the length of `ordinals`.\n            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))\n            // Allocate the memory.\n            mstore(0x40, ptr)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to grant `user` `roles`.\n    /// If the `user` already has a role, then it will be an no-op for the role.\n    function grantRoles(address user, uint256 roles) public payable virtual onlyOwner {\n        _grantRoles(user, roles);\n    }\n\n    /// @dev Allows the owner to remove `user` `roles`.\n    /// If the `user` does not have a role, then it will be an no-op for the role.\n    function revokeRoles(address user, uint256 roles) public payable virtual onlyOwner {\n        _removeRoles(user, roles);\n    }\n\n    /// @dev Allow the caller to remove their own roles.\n    /// If the caller does not have a role, then it will be an no-op for the role.\n    function renounceRoles(uint256 roles) public payable virtual {\n        _removeRoles(msg.sender, roles);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the roles of `user`.\n    function rolesOf(address user) public view virtual returns (uint256 roles) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the role slot.\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, user)\n            // Load the stored value.\n            roles := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns whether `user` has any of `roles`.\n    function hasAnyRole(address user, uint256 roles) public view virtual returns (bool) {\n        return rolesOf(user) & roles != 0;\n    }\n\n    /// @dev Returns whether `user` has all of `roles`.\n    function hasAllRoles(address user, uint256 roles) public view virtual returns (bool) {\n        return rolesOf(user) & roles == roles;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by an account with `roles`.\n    modifier onlyRoles(uint256 roles) virtual {\n        _checkRoles(roles);\n        _;\n    }\n\n    /// @dev Marks a function as only callable by the owner or by an account\n    /// with `roles`. Checks for ownership first, then lazily checks for roles.\n    modifier onlyOwnerOrRoles(uint256 roles) virtual {\n        _checkOwnerOrRoles(roles);\n        _;\n    }\n\n    /// @dev Marks a function as only callable by an account with `roles`\n    /// or the owner. Checks for roles first, then lazily checks for ownership.\n    modifier onlyRolesOrOwner(uint256 roles) virtual {\n        _checkRolesOrOwner(roles);\n        _;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ROLE CONSTANTS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // IYKYK\n\n    uint256 internal constant _ROLE_0 = 1 << 0;\n    uint256 internal constant _ROLE_1 = 1 << 1;\n    uint256 internal constant _ROLE_2 = 1 << 2;\n    uint256 internal constant _ROLE_3 = 1 << 3;\n    uint256 internal constant _ROLE_4 = 1 << 4;\n    uint256 internal constant _ROLE_5 = 1 << 5;\n    uint256 internal constant _ROLE_6 = 1 << 6;\n    uint256 internal constant _ROLE_7 = 1 << 7;\n    uint256 internal constant _ROLE_8 = 1 << 8;\n    uint256 internal constant _ROLE_9 = 1 << 9;\n    uint256 internal constant _ROLE_10 = 1 << 10;\n    uint256 internal constant _ROLE_11 = 1 << 11;\n    uint256 internal constant _ROLE_12 = 1 << 12;\n    uint256 internal constant _ROLE_13 = 1 << 13;\n    uint256 internal constant _ROLE_14 = 1 << 14;\n    uint256 internal constant _ROLE_15 = 1 << 15;\n    uint256 internal constant _ROLE_16 = 1 << 16;\n    uint256 internal constant _ROLE_17 = 1 << 17;\n    uint256 internal constant _ROLE_18 = 1 << 18;\n    uint256 internal constant _ROLE_19 = 1 << 19;\n    uint256 internal constant _ROLE_20 = 1 << 20;\n    uint256 internal constant _ROLE_21 = 1 << 21;\n    uint256 internal constant _ROLE_22 = 1 << 22;\n    uint256 internal constant _ROLE_23 = 1 << 23;\n    uint256 internal constant _ROLE_24 = 1 << 24;\n    uint256 internal constant _ROLE_25 = 1 << 25;\n    uint256 internal constant _ROLE_26 = 1 << 26;\n    uint256 internal constant _ROLE_27 = 1 << 27;\n    uint256 internal constant _ROLE_28 = 1 << 28;\n    uint256 internal constant _ROLE_29 = 1 << 29;\n    uint256 internal constant _ROLE_30 = 1 << 30;\n    uint256 internal constant _ROLE_31 = 1 << 31;\n    uint256 internal constant _ROLE_32 = 1 << 32;\n    uint256 internal constant _ROLE_33 = 1 << 33;\n    uint256 internal constant _ROLE_34 = 1 << 34;\n    uint256 internal constant _ROLE_35 = 1 << 35;\n    uint256 internal constant _ROLE_36 = 1 << 36;\n    uint256 internal constant _ROLE_37 = 1 << 37;\n    uint256 internal constant _ROLE_38 = 1 << 38;\n    uint256 internal constant _ROLE_39 = 1 << 39;\n    uint256 internal constant _ROLE_40 = 1 << 40;\n    uint256 internal constant _ROLE_41 = 1 << 41;\n    uint256 internal constant _ROLE_42 = 1 << 42;\n    uint256 internal constant _ROLE_43 = 1 << 43;\n    uint256 internal constant _ROLE_44 = 1 << 44;\n    uint256 internal constant _ROLE_45 = 1 << 45;\n    uint256 internal constant _ROLE_46 = 1 << 46;\n    uint256 internal constant _ROLE_47 = 1 << 47;\n    uint256 internal constant _ROLE_48 = 1 << 48;\n    uint256 internal constant _ROLE_49 = 1 << 49;\n    uint256 internal constant _ROLE_50 = 1 << 50;\n    uint256 internal constant _ROLE_51 = 1 << 51;\n    uint256 internal constant _ROLE_52 = 1 << 52;\n    uint256 internal constant _ROLE_53 = 1 << 53;\n    uint256 internal constant _ROLE_54 = 1 << 54;\n    uint256 internal constant _ROLE_55 = 1 << 55;\n    uint256 internal constant _ROLE_56 = 1 << 56;\n    uint256 internal constant _ROLE_57 = 1 << 57;\n    uint256 internal constant _ROLE_58 = 1 << 58;\n    uint256 internal constant _ROLE_59 = 1 << 59;\n    uint256 internal constant _ROLE_60 = 1 << 60;\n    uint256 internal constant _ROLE_61 = 1 << 61;\n    uint256 internal constant _ROLE_62 = 1 << 62;\n    uint256 internal constant _ROLE_63 = 1 << 63;\n    uint256 internal constant _ROLE_64 = 1 << 64;\n    uint256 internal constant _ROLE_65 = 1 << 65;\n    uint256 internal constant _ROLE_66 = 1 << 66;\n    uint256 internal constant _ROLE_67 = 1 << 67;\n    uint256 internal constant _ROLE_68 = 1 << 68;\n    uint256 internal constant _ROLE_69 = 1 << 69;\n    uint256 internal constant _ROLE_70 = 1 << 70;\n    uint256 internal constant _ROLE_71 = 1 << 71;\n    uint256 internal constant _ROLE_72 = 1 << 72;\n    uint256 internal constant _ROLE_73 = 1 << 73;\n    uint256 internal constant _ROLE_74 = 1 << 74;\n    uint256 internal constant _ROLE_75 = 1 << 75;\n    uint256 internal constant _ROLE_76 = 1 << 76;\n    uint256 internal constant _ROLE_77 = 1 << 77;\n    uint256 internal constant _ROLE_78 = 1 << 78;\n    uint256 internal constant _ROLE_79 = 1 << 79;\n    uint256 internal constant _ROLE_80 = 1 << 80;\n    uint256 internal constant _ROLE_81 = 1 << 81;\n    uint256 internal constant _ROLE_82 = 1 << 82;\n    uint256 internal constant _ROLE_83 = 1 << 83;\n    uint256 internal constant _ROLE_84 = 1 << 84;\n    uint256 internal constant _ROLE_85 = 1 << 85;\n    uint256 internal constant _ROLE_86 = 1 << 86;\n    uint256 internal constant _ROLE_87 = 1 << 87;\n    uint256 internal constant _ROLE_88 = 1 << 88;\n    uint256 internal constant _ROLE_89 = 1 << 89;\n    uint256 internal constant _ROLE_90 = 1 << 90;\n    uint256 internal constant _ROLE_91 = 1 << 91;\n    uint256 internal constant _ROLE_92 = 1 << 92;\n    uint256 internal constant _ROLE_93 = 1 << 93;\n    uint256 internal constant _ROLE_94 = 1 << 94;\n    uint256 internal constant _ROLE_95 = 1 << 95;\n    uint256 internal constant _ROLE_96 = 1 << 96;\n    uint256 internal constant _ROLE_97 = 1 << 97;\n    uint256 internal constant _ROLE_98 = 1 << 98;\n    uint256 internal constant _ROLE_99 = 1 << 99;\n    uint256 internal constant _ROLE_100 = 1 << 100;\n    uint256 internal constant _ROLE_101 = 1 << 101;\n    uint256 internal constant _ROLE_102 = 1 << 102;\n    uint256 internal constant _ROLE_103 = 1 << 103;\n    uint256 internal constant _ROLE_104 = 1 << 104;\n    uint256 internal constant _ROLE_105 = 1 << 105;\n    uint256 internal constant _ROLE_106 = 1 << 106;\n    uint256 internal constant _ROLE_107 = 1 << 107;\n    uint256 internal constant _ROLE_108 = 1 << 108;\n    uint256 internal constant _ROLE_109 = 1 << 109;\n    uint256 internal constant _ROLE_110 = 1 << 110;\n    uint256 internal constant _ROLE_111 = 1 << 111;\n    uint256 internal constant _ROLE_112 = 1 << 112;\n    uint256 internal constant _ROLE_113 = 1 << 113;\n    uint256 internal constant _ROLE_114 = 1 << 114;\n    uint256 internal constant _ROLE_115 = 1 << 115;\n    uint256 internal constant _ROLE_116 = 1 << 116;\n    uint256 internal constant _ROLE_117 = 1 << 117;\n    uint256 internal constant _ROLE_118 = 1 << 118;\n    uint256 internal constant _ROLE_119 = 1 << 119;\n    uint256 internal constant _ROLE_120 = 1 << 120;\n    uint256 internal constant _ROLE_121 = 1 << 121;\n    uint256 internal constant _ROLE_122 = 1 << 122;\n    uint256 internal constant _ROLE_123 = 1 << 123;\n    uint256 internal constant _ROLE_124 = 1 << 124;\n    uint256 internal constant _ROLE_125 = 1 << 125;\n    uint256 internal constant _ROLE_126 = 1 << 126;\n    uint256 internal constant _ROLE_127 = 1 << 127;\n    uint256 internal constant _ROLE_128 = 1 << 128;\n    uint256 internal constant _ROLE_129 = 1 << 129;\n    uint256 internal constant _ROLE_130 = 1 << 130;\n    uint256 internal constant _ROLE_131 = 1 << 131;\n    uint256 internal constant _ROLE_132 = 1 << 132;\n    uint256 internal constant _ROLE_133 = 1 << 133;\n    uint256 internal constant _ROLE_134 = 1 << 134;\n    uint256 internal constant _ROLE_135 = 1 << 135;\n    uint256 internal constant _ROLE_136 = 1 << 136;\n    uint256 internal constant _ROLE_137 = 1 << 137;\n    uint256 internal constant _ROLE_138 = 1 << 138;\n    uint256 internal constant _ROLE_139 = 1 << 139;\n    uint256 internal constant _ROLE_140 = 1 << 140;\n    uint256 internal constant _ROLE_141 = 1 << 141;\n    uint256 internal constant _ROLE_142 = 1 << 142;\n    uint256 internal constant _ROLE_143 = 1 << 143;\n    uint256 internal constant _ROLE_144 = 1 << 144;\n    uint256 internal constant _ROLE_145 = 1 << 145;\n    uint256 internal constant _ROLE_146 = 1 << 146;\n    uint256 internal constant _ROLE_147 = 1 << 147;\n    uint256 internal constant _ROLE_148 = 1 << 148;\n    uint256 internal constant _ROLE_149 = 1 << 149;\n    uint256 internal constant _ROLE_150 = 1 << 150;\n    uint256 internal constant _ROLE_151 = 1 << 151;\n    uint256 internal constant _ROLE_152 = 1 << 152;\n    uint256 internal constant _ROLE_153 = 1 << 153;\n    uint256 internal constant _ROLE_154 = 1 << 154;\n    uint256 internal constant _ROLE_155 = 1 << 155;\n    uint256 internal constant _ROLE_156 = 1 << 156;\n    uint256 internal constant _ROLE_157 = 1 << 157;\n    uint256 internal constant _ROLE_158 = 1 << 158;\n    uint256 internal constant _ROLE_159 = 1 << 159;\n    uint256 internal constant _ROLE_160 = 1 << 160;\n    uint256 internal constant _ROLE_161 = 1 << 161;\n    uint256 internal constant _ROLE_162 = 1 << 162;\n    uint256 internal constant _ROLE_163 = 1 << 163;\n    uint256 internal constant _ROLE_164 = 1 << 164;\n    uint256 internal constant _ROLE_165 = 1 << 165;\n    uint256 internal constant _ROLE_166 = 1 << 166;\n    uint256 internal constant _ROLE_167 = 1 << 167;\n    uint256 internal constant _ROLE_168 = 1 << 168;\n    uint256 internal constant _ROLE_169 = 1 << 169;\n    uint256 internal constant _ROLE_170 = 1 << 170;\n    uint256 internal constant _ROLE_171 = 1 << 171;\n    uint256 internal constant _ROLE_172 = 1 << 172;\n    uint256 internal constant _ROLE_173 = 1 << 173;\n    uint256 internal constant _ROLE_174 = 1 << 174;\n    uint256 internal constant _ROLE_175 = 1 << 175;\n    uint256 internal constant _ROLE_176 = 1 << 176;\n    uint256 internal constant _ROLE_177 = 1 << 177;\n    uint256 internal constant _ROLE_178 = 1 << 178;\n    uint256 internal constant _ROLE_179 = 1 << 179;\n    uint256 internal constant _ROLE_180 = 1 << 180;\n    uint256 internal constant _ROLE_181 = 1 << 181;\n    uint256 internal constant _ROLE_182 = 1 << 182;\n    uint256 internal constant _ROLE_183 = 1 << 183;\n    uint256 internal constant _ROLE_184 = 1 << 184;\n    uint256 internal constant _ROLE_185 = 1 << 185;\n    uint256 internal constant _ROLE_186 = 1 << 186;\n    uint256 internal constant _ROLE_187 = 1 << 187;\n    uint256 internal constant _ROLE_188 = 1 << 188;\n    uint256 internal constant _ROLE_189 = 1 << 189;\n    uint256 internal constant _ROLE_190 = 1 << 190;\n    uint256 internal constant _ROLE_191 = 1 << 191;\n    uint256 internal constant _ROLE_192 = 1 << 192;\n    uint256 internal constant _ROLE_193 = 1 << 193;\n    uint256 internal constant _ROLE_194 = 1 << 194;\n    uint256 internal constant _ROLE_195 = 1 << 195;\n    uint256 internal constant _ROLE_196 = 1 << 196;\n    uint256 internal constant _ROLE_197 = 1 << 197;\n    uint256 internal constant _ROLE_198 = 1 << 198;\n    uint256 internal constant _ROLE_199 = 1 << 199;\n    uint256 internal constant _ROLE_200 = 1 << 200;\n    uint256 internal constant _ROLE_201 = 1 << 201;\n    uint256 internal constant _ROLE_202 = 1 << 202;\n    uint256 internal constant _ROLE_203 = 1 << 203;\n    uint256 internal constant _ROLE_204 = 1 << 204;\n    uint256 internal constant _ROLE_205 = 1 << 205;\n    uint256 internal constant _ROLE_206 = 1 << 206;\n    uint256 internal constant _ROLE_207 = 1 << 207;\n    uint256 internal constant _ROLE_208 = 1 << 208;\n    uint256 internal constant _ROLE_209 = 1 << 209;\n    uint256 internal constant _ROLE_210 = 1 << 210;\n    uint256 internal constant _ROLE_211 = 1 << 211;\n    uint256 internal constant _ROLE_212 = 1 << 212;\n    uint256 internal constant _ROLE_213 = 1 << 213;\n    uint256 internal constant _ROLE_214 = 1 << 214;\n    uint256 internal constant _ROLE_215 = 1 << 215;\n    uint256 internal constant _ROLE_216 = 1 << 216;\n    uint256 internal constant _ROLE_217 = 1 << 217;\n    uint256 internal constant _ROLE_218 = 1 << 218;\n    uint256 internal constant _ROLE_219 = 1 << 219;\n    uint256 internal constant _ROLE_220 = 1 << 220;\n    uint256 internal constant _ROLE_221 = 1 << 221;\n    uint256 internal constant _ROLE_222 = 1 << 222;\n    uint256 internal constant _ROLE_223 = 1 << 223;\n    uint256 internal constant _ROLE_224 = 1 << 224;\n    uint256 internal constant _ROLE_225 = 1 << 225;\n    uint256 internal constant _ROLE_226 = 1 << 226;\n    uint256 internal constant _ROLE_227 = 1 << 227;\n    uint256 internal constant _ROLE_228 = 1 << 228;\n    uint256 internal constant _ROLE_229 = 1 << 229;\n    uint256 internal constant _ROLE_230 = 1 << 230;\n    uint256 internal constant _ROLE_231 = 1 << 231;\n    uint256 internal constant _ROLE_232 = 1 << 232;\n    uint256 internal constant _ROLE_233 = 1 << 233;\n    uint256 internal constant _ROLE_234 = 1 << 234;\n    uint256 internal constant _ROLE_235 = 1 << 235;\n    uint256 internal constant _ROLE_236 = 1 << 236;\n    uint256 internal constant _ROLE_237 = 1 << 237;\n    uint256 internal constant _ROLE_238 = 1 << 238;\n    uint256 internal constant _ROLE_239 = 1 << 239;\n    uint256 internal constant _ROLE_240 = 1 << 240;\n    uint256 internal constant _ROLE_241 = 1 << 241;\n    uint256 internal constant _ROLE_242 = 1 << 242;\n    uint256 internal constant _ROLE_243 = 1 << 243;\n    uint256 internal constant _ROLE_244 = 1 << 244;\n    uint256 internal constant _ROLE_245 = 1 << 245;\n    uint256 internal constant _ROLE_246 = 1 << 246;\n    uint256 internal constant _ROLE_247 = 1 << 247;\n    uint256 internal constant _ROLE_248 = 1 << 248;\n    uint256 internal constant _ROLE_249 = 1 << 249;\n    uint256 internal constant _ROLE_250 = 1 << 250;\n    uint256 internal constant _ROLE_251 = 1 << 251;\n    uint256 internal constant _ROLE_252 = 1 << 252;\n    uint256 internal constant _ROLE_253 = 1 << 253;\n    uint256 internal constant _ROLE_254 = 1 << 254;\n    uint256 internal constant _ROLE_255 = 1 << 255;\n}\n"},"contracts/interfaces/IQuestFactory.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.19;\r\n\r\ninterface IQuestFactory {\r\n    // Errors\r\n    error AddressAlreadyMinted();\r\n    error AddressNotSigned();\r\n    error AddressZeroNotAllowed();\r\n    error AuthOwnerDiscountToken();\r\n    error Deprecated();\r\n    error Erc20QuestAddressNotSet();\r\n    error InvalidMintFee();\r\n    error MsgValueLessThanQuestNFTFee();\r\n    error OverMaxAllowedToMint();\r\n    error QuestFeeTooHigh();\r\n    error QuestIdUsed();\r\n    error QuestNotQueued();\r\n    error QuestNotStarted();\r\n    error QuestEnded();\r\n    error QuestTypeNotSupported();\r\n    error Reentrancy();\r\n    error ReferralFeeTooHigh();\r\n    error ZeroAddressNotAllowed();\r\n    error QuestAddressMismatch();\r\n    error ClaimFailed();\r\n    error txOriginMismatch();\r\n\r\n    // Structs\r\n\r\n    // This struct is used in a mapping - only add new fields to the end\r\n    struct NftQuestFees {\r\n        uint256 fee;\r\n        bool exists;\r\n    }\r\n\r\n    // This struct is used in a mapping - only add new fields to the end\r\n    struct Quest {\r\n        mapping(address => bool) addressMinted;\r\n        address questAddress;\r\n        uint256 totalParticipants;\r\n        uint256 numberMinted;\r\n        string questType;\r\n        uint40 durationTotal;\r\n        address questCreator;\r\n        address mintFeeRecipient;\r\n        string actionType;\r\n        string questName;\r\n        uint32 txHashChainId;\r\n    }\r\n\r\n    struct QuestData {\r\n        address questAddress;\r\n        address rewardToken;\r\n        bool queued;\r\n        uint16 questFee;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 totalParticipants;\r\n        uint256 numberMinted;\r\n        uint256 redeemedTokens;\r\n        uint256 rewardAmountOrTokenId;\r\n        bool hasWithdrawn;\r\n    }\r\n\r\n    struct QuestJsonData {\r\n        string actionType;\r\n        string questName;\r\n        uint32 txHashChainId;\r\n    }\r\n\r\n    struct ClaimData {\r\n        string questId;\r\n        bytes32 hashBytes;\r\n        bytes signature;\r\n        address ref;\r\n        address claimer;\r\n        string extraData;\r\n    }\r\n\r\n    struct ERC20QuestData {\r\n        uint32 txHashChainId;\r\n        address rewardTokenAddress;\r\n        uint256 endTime;\r\n        uint256 startTime;\r\n        uint256 totalParticipants;\r\n        uint256 rewardAmount;\r\n        string questId;\r\n        string actionType;\r\n        string questName;\r\n        string questType;\r\n        string projectName;\r\n    }\r\n\r\n    struct ERC1155QuestData {\r\n        uint32 txHashChainId;\r\n        address rewardTokenAddress;\r\n        uint256 endTime;\r\n        uint256 startTime;\r\n        uint256 totalParticipants;\r\n        uint256 tokenId;\r\n        string questId;\r\n        string actionType;\r\n        string questName;\r\n        string projectName;\r\n    }\r\n\r\n    // Events\r\n    event ExtraMintFeeReturned(address indexed recipient, uint256 amount);\r\n    event MintFeeSet(uint256 mintFee);\r\n    event NftQuestFeeListSet(address[] addresses, uint256[] fees);\r\n    event NftQuestFeeSet(uint256 nftQuestFee);\r\n\r\n    event QuestClaimedData(\r\n        address indexed recipient,\r\n        address indexed questAddress,\r\n        string extraData\r\n    );\r\n    event Quest1155Claimed(\r\n        address indexed recipient,\r\n        address indexed questAddress,\r\n        string questId,\r\n        address rewardToken,\r\n        uint256 tokenId\r\n    );\r\n    event QuestClaimed(\r\n        address indexed recipient,\r\n        address indexed questAddress,\r\n        string questId,\r\n        address rewardToken,\r\n        uint256 rewardAmountInWei\r\n    );\r\n    event QuestClaimedReferred(\r\n        address indexed recipient,\r\n        address indexed questAddress,\r\n        string questId,\r\n        address rewardToken,\r\n        uint256 rewardAmountInWeiOrTokenId,\r\n        address referrer,\r\n        uint16 referralFee,\r\n        uint256 mintFeeEthWei\r\n    );\r\n    event MintFeePaid(\r\n        string questId,\r\n        address rabbitHoleAddress,\r\n        uint256 rabbitHoleAmountWei,\r\n        address questCreatorAddress,\r\n        uint256 questCreatorAmountWei,\r\n        address referrerAddress,\r\n        uint256 referrerAmountWei\r\n    );\r\n    event QuestCreated(\r\n        address indexed creator,\r\n        address indexed contractAddress,\r\n        string projectName,\r\n        string questName,\r\n        string questId,\r\n        string questType,\r\n        string actionType,\r\n        uint32 chainId,\r\n        address rewardToken,\r\n        uint256 endTime,\r\n        uint256 startTime,\r\n        uint256 totalParticipants,\r\n        uint256 rewardAmountOrTokenId\r\n    );\r\n    event ReferralFeeSet(uint16 percent);\r\n\r\n    // Read Functions\r\n    function getAddressMinted(string memory questId_, address address_) external view returns (bool);\r\n    function getNumberMinted(string memory questId_) external view returns (uint256);\r\n    function questData(string memory questId_) external view returns (QuestData memory);\r\n    function questInfo(string memory questId_) external view returns (address, uint256, uint256);\r\n    function recoverSigner(bytes32 hash_, bytes memory signature_) external view returns (address);\r\n    function mintFee() external view returns (uint256);\r\n    function questJsonData(string memory questId_) external view returns (QuestJsonData memory);\r\n    function buildJsonString(\r\n        bytes32 txHash,\r\n        uint32 txHashChainId,\r\n        string memory actionType,\r\n        string memory questName\r\n    ) external pure returns (string memory);\r\n\r\n    // Create\r\n    function create1155QuestAndQueue(\r\n        address rewardTokenAddress_,\r\n        uint256 endTime_,\r\n        uint256 startTime_,\r\n        uint256 totalParticipants_,\r\n        uint256 tokenId_,\r\n        string memory questId_,\r\n        string memory\r\n    ) external payable returns (address);\r\n\r\n    function claimOptimized(bytes calldata signature_, bytes calldata data_) external payable;\r\n\r\n    // Set\r\n    function setClaimSignerAddress(address claimSignerAddress_) external;\r\n    function setErc1155QuestAddress(address erc1155QuestAddress_) external;\r\n    function setErc20QuestAddress(address erc20QuestAddress_) external;\r\n    function setMintFee(uint256 mintFee_) external;\r\n    function setDefaultMintFeeRecipient(address mintFeeRecipient_) external;\r\n    function setProtocolFeeRecipient(address protocolFeeRecipient_) external;\r\n    function setQuestFee(uint16 questFee_) external;\r\n\r\n    // Callbacks\r\n    function withdrawCallback(string calldata questId_, address protocolFeeRecipient_, uint protocolPayout_, address mintFeeRecipient_, uint mintPayout) external;\r\n}"},"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"},"lib/solady/src/utils/LibClone.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Minimal proxy library.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\r\n/// @author Minimal proxy by 0age (https://github.com/0age)\r\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\r\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\r\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\r\n///\r\n/// @dev Minimal proxy:\r\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\r\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\r\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\r\n///\r\n/// @dev Minimal proxy (PUSH0 variant):\r\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\r\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\r\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \"_PUSH0\" as\r\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\r\n/// Please use with caution.\r\n///\r\n/// @dev Clones with immutable args (CWIA):\r\n/// The implementation of CWIA here implements a `receive()` method that emits the\r\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\r\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\r\n/// composability. The minimal proxy implementation does not offer this feature.\r\n///\r\n/// @dev Minimal ERC1967 proxy:\r\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\r\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\r\nlibrary LibClone {\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Unable to deploy the clone.\r\n    error DeploymentFailed();\r\n\r\n    /// @dev The salt must start with either the zero address or `by`.\r\n    error SaltDoesNotStartWith();\r\n\r\n    /// @dev The ETH transfer has failed.\r\n    error ETHTransferFailed();\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                  MINIMAL PROXY OPERATIONS                  */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Deploys a clone of `implementation`.\r\n    function clone(address implementation) internal returns (address instance) {\r\n        instance = clone(0, implementation);\r\n    }\r\n\r\n    /// @dev Deploys a clone of `implementation`.\r\n    function clone(uint256 value, address implementation) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            /**\r\n             * --------------------------------------------------------------------------+\r\n             * CREATION (9 bytes)                                                        |\r\n             * --------------------------------------------------------------------------|\r\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\r\n             * --------------------------------------------------------------------------|\r\n             * 60 runSize | PUSH1 runSize     | r         |                              |\r\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\r\n             * 81         | DUP2              | r 0 r     |                              |\r\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\r\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\r\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\r\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\r\n             * --------------------------------------------------------------------------|\r\n             * RUNTIME (44 bytes)                                                        |\r\n             * --------------------------------------------------------------------------|\r\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\r\n             * --------------------------------------------------------------------------|\r\n             *                                                                           |\r\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 3d      | RETURNDATASIZE | 0                      |                       |\r\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\r\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\r\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\r\n             *                                                                           |\r\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\r\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\r\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\r\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\r\n             *                                                                           |\r\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\r\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\r\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\r\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\r\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\r\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\r\n             *                                                                           |\r\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\r\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\r\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\r\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\r\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\r\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\r\n             *                                                                           |\r\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\r\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\r\n             *                                                                           |\r\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * fd      | REVERT         |                        | [0..rds): returndata  |\r\n             *                                                                           |\r\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\r\n             * f3      | RETURN         |                        | [0..rds): returndata  |\r\n             * --------------------------------------------------------------------------+\r\n             */\r\n\r\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\r\n            mstore(0x14, implementation)\r\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\r\n            instance := create(value, 0x0c, 0x35)\r\n            if iszero(instance) {\r\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\r\n    function cloneDeterministic(address implementation, bytes32 salt)\r\n        internal\r\n        returns (address instance)\r\n    {\r\n        instance = cloneDeterministic(0, implementation, salt);\r\n    }\r\n\r\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\r\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\r\n        internal\r\n        returns (address instance)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\r\n            mstore(0x14, implementation)\r\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\r\n            instance := create2(value, 0x0c, 0x35, salt)\r\n            if iszero(instance) {\r\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\r\n    /// Used for mining vanity addresses with create2crunch.\r\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\r\n            mstore(0x14, implementation)\r\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\r\n            hash := keccak256(0x0c, 0x35)\r\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the address of the deterministic clone of `implementation`,\r\n    /// with `salt` by `deployer`.\r\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\r\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\r\n        internal\r\n        pure\r\n        returns (address predicted)\r\n    {\r\n        bytes32 hash = initCodeHash(implementation);\r\n        predicted = predictDeterministicAddress(hash, salt, deployer);\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Deploys a PUSH0 clone of `implementation`.\r\n    function clone_PUSH0(address implementation) internal returns (address instance) {\r\n        instance = clone_PUSH0(0, implementation);\r\n    }\r\n\r\n    /// @dev Deploys a PUSH0 clone of `implementation`.\r\n    function clone_PUSH0(uint256 value, address implementation)\r\n        internal\r\n        returns (address instance)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            /**\r\n             * --------------------------------------------------------------------------+\r\n             * CREATION (9 bytes)                                                        |\r\n             * --------------------------------------------------------------------------|\r\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\r\n             * --------------------------------------------------------------------------|\r\n             * 60 runSize | PUSH1 runSize     | r         |                              |\r\n             * 5f         | PUSH0             | 0 r       |                              |\r\n             * 81         | DUP2              | r 0 r     |                              |\r\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\r\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\r\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\r\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\r\n             * --------------------------------------------------------------------------|\r\n             * RUNTIME (45 bytes)                                                        |\r\n             * --------------------------------------------------------------------------|\r\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\r\n             * --------------------------------------------------------------------------|\r\n             *                                                                           |\r\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 5f      | PUSH0          | 0                      |                       |\r\n             * 5f      | PUSH0          | 0 0                    |                       |\r\n             *                                                                           |\r\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\r\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\r\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\r\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\r\n             *                                                                           |\r\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\r\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\r\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\r\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\r\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\r\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\r\n             *                                                                           |\r\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\r\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\r\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\r\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\r\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\r\n             *                                                                           |\r\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\r\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\r\n             *                                                                           |\r\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\r\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\r\n             * fd      | REVERT         |                        | [0..rds): returndata  |\r\n             *                                                                           |\r\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\r\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\r\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\r\n             * f3      | RETURN         |                        | [0..rds): returndata  |\r\n             * --------------------------------------------------------------------------+\r\n             */\r\n\r\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\r\n            mstore(0x14, implementation) // 20\r\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\r\n            instance := create(value, 0x0e, 0x36)\r\n            if iszero(instance) {\r\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\r\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\r\n        internal\r\n        returns (address instance)\r\n    {\r\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\r\n    }\r\n\r\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\r\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\r\n        internal\r\n        returns (address instance)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\r\n            mstore(0x14, implementation) // 20\r\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\r\n            instance := create2(value, 0x0e, 0x36, salt)\r\n            if iszero(instance) {\r\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\r\n    /// Used for mining vanity addresses with create2crunch.\r\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\r\n            mstore(0x14, implementation) // 20\r\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\r\n            hash := keccak256(0x0e, 0x36)\r\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\r\n    /// with `salt` by `deployer`.\r\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\r\n    function predictDeterministicAddress_PUSH0(\r\n        address implementation,\r\n        bytes32 salt,\r\n        address deployer\r\n    ) internal pure returns (address predicted) {\r\n        bytes32 hash = initCodeHash_PUSH0(implementation);\r\n        predicted = predictDeterministicAddress(hash, salt, deployer);\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    // Note: This implementation of CWIA differs from the original implementation.\r\n    // If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\r\n\r\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\r\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\r\n        instance = clone(0, implementation, data);\r\n    }\r\n\r\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\r\n    function clone(uint256 value, address implementation, bytes memory data)\r\n        internal\r\n        returns (address instance)\r\n    {\r\n        assembly {\r\n            // Compute the boundaries of the data and cache the memory slots around it.\r\n            let mBefore3 := mload(sub(data, 0x60))\r\n            let mBefore2 := mload(sub(data, 0x40))\r\n            let mBefore1 := mload(sub(data, 0x20))\r\n            let dataLength := mload(data)\r\n            let dataEnd := add(add(data, 0x20), dataLength)\r\n            let mAfter1 := mload(dataEnd)\r\n\r\n            // +2 bytes for telling how much data there is appended to the call.\r\n            let extraLength := add(dataLength, 2)\r\n            // The `creationSize` is `extraLength + 108`\r\n            // The `runSize` is `creationSize - 10`.\r\n\r\n            /**\r\n             * ---------------------------------------------------------------------------------------------------+\r\n             * CREATION (10 bytes)                                                                                |\r\n             * ---------------------------------------------------------------------------------------------------|\r\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\r\n             * ---------------------------------------------------------------------------------------------------|\r\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\r\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\r\n             * 81         | DUP2              | r 0 r     |                                                       |\r\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\r\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\r\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\r\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\r\n             * ---------------------------------------------------------------------------------------------------|\r\n             * RUNTIME (98 bytes + extraLength)                                                                   |\r\n             * ---------------------------------------------------------------------------------------------------|\r\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\r\n             * ---------------------------------------------------------------------------------------------------|\r\n             *                                                                                                    |\r\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\r\n             * 36       | CALLDATASIZE   | cds                      |                                             |\r\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\r\n             * 57       | JUMPI          |                          |                                             |\r\n             * 34       | CALLVALUE      | cv                       |                                             |\r\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\r\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\r\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\r\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\r\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\r\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\r\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\r\n             * 5b       | JUMPDEST       |                          |                                             |\r\n             *                                                                                                    |\r\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 36       | CALLDATASIZE   | cds                      |                                             |\r\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\r\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\r\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\r\n             *                                                                                                    |\r\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\r\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\r\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\r\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\r\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\r\n             *                                                                                                    |\r\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\r\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\r\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\r\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\r\n             *                                                                                                    |\r\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\r\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\r\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\r\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\r\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\r\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\r\n             *                                                                                                    |\r\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\r\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\r\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\r\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\r\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\r\n             *                                                                                                    |\r\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\r\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\r\n             *                                                                                                    |\r\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\r\n             *                                                                                                    |\r\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\r\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\r\n             * ---------------------------------------------------------------------------------------------------+\r\n             */\r\n\r\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\r\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\r\n            // Write the rest of the bytecode.\r\n            mstore(\r\n                sub(data, 0x21),\r\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\r\n            )\r\n            // `keccak256(\"ReceiveETH(uint256)\")`\r\n            mstore(\r\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\r\n            )\r\n            mstore(\r\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\r\n                // The actual EVM limit may be smaller and may change over time.\r\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\r\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\r\n            )\r\n            mstore(dataEnd, shl(0xf0, extraLength))\r\n\r\n            instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))\r\n            if iszero(instance) {\r\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            // Restore the overwritten memory surrounding `data`.\r\n            mstore(dataEnd, mAfter1)\r\n            mstore(data, dataLength)\r\n            mstore(sub(data, 0x20), mBefore1)\r\n            mstore(sub(data, 0x40), mBefore2)\r\n            mstore(sub(data, 0x60), mBefore3)\r\n        }\r\n    }\r\n\r\n    /// @dev Deploys a deterministic clone of `implementation`\r\n    /// with immutable arguments encoded in `data` and `salt`.\r\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\r\n        internal\r\n        returns (address instance)\r\n    {\r\n        instance = cloneDeterministic(0, implementation, data, salt);\r\n    }\r\n\r\n    /// @dev Deploys a deterministic clone of `implementation`\r\n    /// with immutable arguments encoded in `data` and `salt`.\r\n    function cloneDeterministic(\r\n        uint256 value,\r\n        address implementation,\r\n        bytes memory data,\r\n        bytes32 salt\r\n    ) internal returns (address instance) {\r\n        assembly {\r\n            // Compute the boundaries of the data and cache the memory slots around it.\r\n            let mBefore3 := mload(sub(data, 0x60))\r\n            let mBefore2 := mload(sub(data, 0x40))\r\n            let mBefore1 := mload(sub(data, 0x20))\r\n            let dataLength := mload(data)\r\n            let dataEnd := add(add(data, 0x20), dataLength)\r\n            let mAfter1 := mload(dataEnd)\r\n\r\n            // +2 bytes for telling how much data there is appended to the call.\r\n            let extraLength := add(dataLength, 2)\r\n\r\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\r\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\r\n            // Write the rest of the bytecode.\r\n            mstore(\r\n                sub(data, 0x21),\r\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\r\n            )\r\n            // `keccak256(\"ReceiveETH(uint256)\")`\r\n            mstore(\r\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\r\n            )\r\n            mstore(\r\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\r\n                // The actual EVM limit may be smaller and may change over time.\r\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\r\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\r\n            )\r\n            mstore(dataEnd, shl(0xf0, extraLength))\r\n\r\n            instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)\r\n            if iszero(instance) {\r\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            // Restore the overwritten memory surrounding `data`.\r\n            mstore(dataEnd, mAfter1)\r\n            mstore(data, dataLength)\r\n            mstore(sub(data, 0x20), mBefore1)\r\n            mstore(sub(data, 0x40), mBefore2)\r\n            mstore(sub(data, 0x60), mBefore3)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the initialization code hash of the clone of `implementation`\r\n    /// using immutable arguments encoded in `data`.\r\n    /// Used for mining vanity addresses with create2crunch.\r\n    function initCodeHash(address implementation, bytes memory data)\r\n        internal\r\n        pure\r\n        returns (bytes32 hash)\r\n    {\r\n        assembly {\r\n            // Compute the boundaries of the data and cache the memory slots around it.\r\n            let mBefore3 := mload(sub(data, 0x60))\r\n            let mBefore2 := mload(sub(data, 0x40))\r\n            let mBefore1 := mload(sub(data, 0x20))\r\n            let dataLength := mload(data)\r\n            let dataEnd := add(add(data, 0x20), dataLength)\r\n            let mAfter1 := mload(dataEnd)\r\n\r\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\r\n            // The actual EVM limit may be smaller and may change over time.\r\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\r\n\r\n            // +2 bytes for telling how much data there is appended to the call.\r\n            let extraLength := add(dataLength, 2)\r\n\r\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\r\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\r\n            // Write the rest of the bytecode.\r\n            mstore(\r\n                sub(data, 0x21),\r\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\r\n            )\r\n            // `keccak256(\"ReceiveETH(uint256)\")`\r\n            mstore(\r\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\r\n            )\r\n            mstore(\r\n                sub(data, 0x5a),\r\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\r\n            )\r\n            mstore(dataEnd, shl(0xf0, extraLength))\r\n\r\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\r\n\r\n            // Restore the overwritten memory surrounding `data`.\r\n            mstore(dataEnd, mAfter1)\r\n            mstore(data, dataLength)\r\n            mstore(sub(data, 0x20), mBefore1)\r\n            mstore(sub(data, 0x40), mBefore2)\r\n            mstore(sub(data, 0x60), mBefore3)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the address of the deterministic clone of\r\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\r\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\r\n    function predictDeterministicAddress(\r\n        address implementation,\r\n        bytes memory data,\r\n        bytes32 salt,\r\n        address deployer\r\n    ) internal pure returns (address predicted) {\r\n        bytes32 hash = initCodeHash(implementation, data);\r\n        predicted = predictDeterministicAddress(hash, salt, deployer);\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\r\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\r\n\r\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\r\n    function deployERC1967(address implementation) internal returns (address instance) {\r\n        instance = deployERC1967(0, implementation);\r\n    }\r\n\r\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\r\n    function deployERC1967(uint256 value, address implementation)\r\n        internal\r\n        returns (address instance)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            /**\r\n             * ---------------------------------------------------------------------------------+\r\n             * CREATION (34 bytes)                                                              |\r\n             * ---------------------------------------------------------------------------------|\r\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\r\n             * ---------------------------------------------------------------------------------|\r\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\r\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\r\n             * 81         | DUP2           | r 0 r            |                                 |\r\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\r\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\r\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\r\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\r\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\r\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\r\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\r\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\r\n             * ---------------------------------------------------------------------------------|\r\n             * RUNTIME (62 bytes)                                                               |\r\n             * ---------------------------------------------------------------------------------|\r\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\r\n             * ---------------------------------------------------------------------------------|\r\n             *                                                                                  |\r\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 36         | CALLDATASIZE   | cds              |                                 |\r\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\r\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\r\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\r\n             *                                                                                  |\r\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 3d         | RETURNDATASIZE | 0                |                                 |\r\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\r\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\r\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\r\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\r\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\r\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\r\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\r\n             *                                                                                  |\r\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\r\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\r\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\r\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\r\n             *                                                                                  |\r\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\r\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\r\n             *                                                                                  |\r\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\r\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\r\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\r\n             *                                                                                  |\r\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\r\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\r\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\r\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\r\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\r\n             * ---------------------------------------------------------------------------------+\r\n             */\r\n\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\r\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\r\n            mstore(0x20, 0x6009)\r\n            mstore(0x1e, implementation)\r\n            mstore(0x0a, 0x603d3d8160223d3973)\r\n            instance := create(value, 0x21, 0x5f)\r\n            if iszero(instance) {\r\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            mstore(0x60, 0) // Restore the zero slot.\r\n        }\r\n    }\r\n\r\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\r\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\r\n        internal\r\n        returns (address instance)\r\n    {\r\n        instance = deployDeterministicERC1967(0, implementation, salt);\r\n    }\r\n\r\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\r\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\r\n        internal\r\n        returns (address instance)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\r\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\r\n            mstore(0x20, 0x6009)\r\n            mstore(0x1e, implementation)\r\n            mstore(0x0a, 0x603d3d8160223d3973)\r\n            instance := create2(value, 0x21, 0x5f, salt)\r\n            if iszero(instance) {\r\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            mstore(0x60, 0) // Restore the zero slot.\r\n        }\r\n    }\r\n\r\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\r\n    /// Note: This method is intended for use in ERC4337 factories,\r\n    /// which are expected to NOT revert if the proxy is already deployed.\r\n    function createDeterministicERC1967(address implementation, bytes32 salt)\r\n        internal\r\n        returns (bool alreadyDeployed, address instance)\r\n    {\r\n        return createDeterministicERC1967(0, implementation, salt);\r\n    }\r\n\r\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\r\n    /// Note: This method is intended for use in ERC4337 factories,\r\n    /// which are expected to NOT revert if the proxy is already deployed.\r\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\r\n        internal\r\n        returns (bool alreadyDeployed, address instance)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\r\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\r\n            mstore(0x20, 0x6009)\r\n            mstore(0x1e, implementation)\r\n            mstore(0x0a, 0x603d3d8160223d3973)\r\n            // Compute and store the bytecode hash.\r\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\r\n            mstore(m, shl(88, address()))\r\n            mstore8(m, 0xff) // Write the prefix.\r\n            mstore(add(m, 0x15), salt)\r\n            instance := keccak256(m, 0x55)\r\n            for {} 1 {} {\r\n                if iszero(extcodesize(instance)) {\r\n                    instance := create2(value, 0x21, 0x5f, salt)\r\n                    if iszero(instance) {\r\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\r\n                        revert(0x1c, 0x04)\r\n                    }\r\n                    break\r\n                }\r\n                alreadyDeployed := 1\r\n                if iszero(value) { break }\r\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\r\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                break\r\n            }\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            mstore(0x60, 0) // Restore the zero slot.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the initialization code hash of the clone of `implementation`\r\n    /// using immutable arguments encoded in `data`.\r\n    /// Used for mining vanity addresses with create2crunch.\r\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\r\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\r\n            mstore(0x20, 0x6009)\r\n            mstore(0x1e, implementation)\r\n            mstore(0x0a, 0x603d3d8160223d3973)\r\n            hash := keccak256(0x21, 0x5f)\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            mstore(0x60, 0) // Restore the zero slot.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the address of the deterministic clone of\r\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\r\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\r\n    function predictDeterministicAddressERC1967(\r\n        address implementation,\r\n        bytes32 salt,\r\n        address deployer\r\n    ) internal pure returns (address predicted) {\r\n        bytes32 hash = initCodeHashERC1967(implementation);\r\n        predicted = predictDeterministicAddress(hash, salt, deployer);\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                      OTHER OPERATIONS                      */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Returns the address when a contract with initialization code hash,\r\n    /// `hash`, is deployed with `salt`, by `deployer`.\r\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\r\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\r\n        internal\r\n        pure\r\n        returns (address predicted)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute and store the bytecode hash.\r\n            mstore8(0x00, 0xff) // Write the prefix.\r\n            mstore(0x35, hash)\r\n            mstore(0x01, shl(96, deployer))\r\n            mstore(0x15, salt)\r\n            predicted := keccak256(0x00, 0x55)\r\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\r\n    function checkStartsWith(bytes32 salt, address by) internal pure {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // If the salt does not start with the zero address or `by`.\r\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\r\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n}\r\n"},"lib/solady/src/utils/LibString.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Library for converting numbers into strings and other string operations.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\r\nlibrary LibString {\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                        CUSTOM ERRORS                       */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev The `length` of the output is too small to contain all the hex digits.\r\n    error HexLengthInsufficient();\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev The constant returned when the `search` is not found in the string.\r\n    uint256 internal constant NOT_FOUND = type(uint256).max;\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                     DECIMAL OPERATIONS                     */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Returns the base 10 decimal representation of `value`.\r\n    function toString(uint256 value) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\r\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\r\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\r\n            // and 3 words for a maximum of 78 digits.\r\n            str := add(mload(0x40), 0x80)\r\n            // Update the free memory pointer to allocate.\r\n            mstore(0x40, add(str, 0x20))\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end of the memory to calculate the length later.\r\n            let end := str\r\n\r\n            let w := not(0) // Tsk.\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for { let temp := value } 1 {} {\r\n                str := add(str, w) // `sub(str, 1)`.\r\n                // Write the character to the pointer.\r\n                // The ASCII index of the '0' character is 48.\r\n                mstore8(str, add(48, mod(temp, 10)))\r\n                // Keep dividing `temp` until zero.\r\n                temp := div(temp, 10)\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            let length := sub(end, str)\r\n            // Move the pointer 32 bytes leftwards to make room for the length.\r\n            str := sub(str, 0x20)\r\n            // Store the length.\r\n            mstore(str, length)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the base 10 decimal representation of `value`.\r\n    function toString(int256 value) internal pure returns (string memory str) {\r\n        if (value >= 0) {\r\n            return toString(uint256(value));\r\n        }\r\n        unchecked {\r\n            str = toString(uint256(-value));\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We still have some spare memory space on the left,\r\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\r\n            let length := mload(str) // Load the string length.\r\n            mstore(str, 0x2d) // Store the '-' character.\r\n            str := sub(str, 1) // Move back the string pointer by a byte.\r\n            mstore(str, add(length, 1)) // Update the string length.\r\n        }\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                   HEXADECIMAL OPERATIONS                   */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`,\r\n    /// left-padded to an input length of `length` bytes.\r\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\r\n    /// giving a total length of `length * 2 + 2` bytes.\r\n    /// Reverts if `length` is too small for the output to contain all the digits.\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value, length);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`,\r\n    /// left-padded to an input length of `length` bytes.\r\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\r\n    /// giving a total length of `length * 2` bytes.\r\n    /// Reverts if `length` is too small for the output to contain all the digits.\r\n    function toHexStringNoPrefix(uint256 value, uint256 length)\r\n        internal\r\n        pure\r\n        returns (string memory str)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\r\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\r\n            // We add 0x20 to the total and round down to a multiple of 0x20.\r\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\r\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\r\n            // Allocate the memory.\r\n            mstore(0x40, add(str, 0x20))\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end to calculate the length later.\r\n            let end := str\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let start := sub(str, add(length, length))\r\n            let w := not(1) // Tsk.\r\n            let temp := value\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for {} 1 {} {\r\n                str := add(str, w) // `sub(str, 2)`.\r\n                mstore8(add(str, 1), mload(and(temp, 15)))\r\n                mstore8(str, mload(and(shr(4, temp), 15)))\r\n                temp := shr(8, temp)\r\n                if iszero(xor(str, start)) { break }\r\n            }\r\n\r\n            if temp {\r\n                // Store the function selector of `HexLengthInsufficient()`.\r\n                mstore(0x00, 0x2194895a)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            // Compute the string's length.\r\n            let strLength := sub(end, str)\r\n            // Move the pointer and write the length.\r\n            str := sub(str, 0x20)\r\n            mstore(str, strLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\r\n    /// As address are 20 bytes long, the output will left-padded to have\r\n    /// a length of `20 * 2 + 2` bytes.\r\n    function toHexString(uint256 value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\".\r\n    /// The output excludes leading \"0\" from the `toHexString` output.\r\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\r\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\r\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\r\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\r\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\r\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\r\n            let strLength := mload(str) // Get the length.\r\n            str := add(str, o) // Move the pointer, accounting for leading zero.\r\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    /// As address are 20 bytes long, the output will left-padded to have\r\n    /// a length of `20 * 2` bytes.\r\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\r\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\r\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\r\n            str := add(mload(0x40), 0x80)\r\n            // Allocate the memory.\r\n            mstore(0x40, add(str, 0x20))\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end to calculate the length later.\r\n            let end := str\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let w := not(1) // Tsk.\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for { let temp := value } 1 {} {\r\n                str := add(str, w) // `sub(str, 2)`.\r\n                mstore8(add(str, 1), mload(and(temp, 15)))\r\n                mstore8(str, mload(and(shr(4, temp), 15)))\r\n                temp := shr(8, temp)\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            // Compute the string's length.\r\n            let strLength := sub(end, str)\r\n            // Move the pointer and write the length.\r\n            str := sub(str, 0x20)\r\n            mstore(str, strLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\r\n    /// and the alphabets are capitalized conditionally according to\r\n    /// https://eips.ethereum.org/EIPS/eip-55\r\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\r\n        str = toHexString(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\r\n            let o := add(str, 0x22)\r\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\r\n            let t := shl(240, 136) // `0b10001000 << 240`\r\n            for { let i := 0 } 1 {} {\r\n                mstore(add(i, i), mul(t, byte(i, hashed)))\r\n                i := add(i, 1)\r\n                if eq(i, 20) { break }\r\n            }\r\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\r\n            o := add(o, 0x20)\r\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\r\n    function toHexString(address value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            str := mload(0x40)\r\n\r\n            // Allocate the memory.\r\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\r\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\r\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\r\n            mstore(0x40, add(str, 0x80))\r\n\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            str := add(str, 2)\r\n            mstore(str, 40)\r\n\r\n            let o := add(str, 0x20)\r\n            mstore(add(o, 40), 0)\r\n\r\n            value := shl(96, value)\r\n\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for { let i := 0 } 1 {} {\r\n                let p := add(o, add(i, i))\r\n                let temp := byte(i, value)\r\n                mstore8(add(p, 1), mload(and(temp, 15)))\r\n                mstore8(p, mload(shr(4, temp)))\r\n                i := add(i, 1)\r\n                if eq(i, 20) { break }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hex encoded string from the raw bytes.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(raw);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hex encoded string from the raw bytes.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let length := mload(raw)\r\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\r\n            mstore(str, add(length, length)) // Store the length of the output.\r\n\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let o := add(str, 0x20)\r\n            let end := add(raw, length)\r\n\r\n            for {} iszero(eq(raw, end)) {} {\r\n                raw := add(raw, 1)\r\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\r\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\r\n                o := add(o, 2)\r\n            }\r\n            mstore(o, 0) // Zeroize the slot after the string.\r\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\r\n        }\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                   RUNE STRING OPERATIONS                   */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Returns the number of UTF characters in the string.\r\n    function runeCount(string memory s) internal pure returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if mload(s) {\r\n                mstore(0x00, div(not(0), 255))\r\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\r\n                let o := add(s, 0x20)\r\n                let end := add(o, mload(s))\r\n                for { result := 1 } 1 { result := add(result, 1) } {\r\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\r\n                    if iszero(lt(o, end)) { break }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns if this string is a 7-bit ASCII string.\r\n    /// (i.e. all characters codes are in [0..127])\r\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let mask := shl(7, div(not(0), 255))\r\n            result := 1\r\n            let n := mload(s)\r\n            if n {\r\n                let o := add(s, 0x20)\r\n                let end := add(o, n)\r\n                let last := mload(end)\r\n                mstore(end, 0)\r\n                for {} 1 {} {\r\n                    if and(mask, mload(o)) {\r\n                        result := 0\r\n                        break\r\n                    }\r\n                    o := add(o, 0x20)\r\n                    if iszero(lt(o, end)) { break }\r\n                }\r\n                mstore(end, last)\r\n            }\r\n        }\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                   BYTE STRING OPERATIONS                   */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    // For performance and bytecode compactness, all indices of the following operations\r\n    // are byte (ASCII) offsets, not UTF character offsets.\r\n\r\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\r\n    function replace(string memory subject, string memory search, string memory replacement)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            let searchLength := mload(search)\r\n            let replacementLength := mload(replacement)\r\n\r\n            subject := add(subject, 0x20)\r\n            search := add(search, 0x20)\r\n            replacement := add(replacement, 0x20)\r\n            result := add(mload(0x40), 0x20)\r\n\r\n            let subjectEnd := add(subject, subjectLength)\r\n            if iszero(gt(searchLength, subjectLength)) {\r\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\r\n                let h := 0\r\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\r\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\r\n                let s := mload(search)\r\n                for {} 1 {} {\r\n                    let t := mload(subject)\r\n                    // Whether the first `searchLength % 32` bytes of\r\n                    // `subject` and `search` matches.\r\n                    if iszero(shr(m, xor(t, s))) {\r\n                        if h {\r\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\r\n                                mstore(result, t)\r\n                                result := add(result, 1)\r\n                                subject := add(subject, 1)\r\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                                continue\r\n                            }\r\n                        }\r\n                        // Copy the `replacement` one word at a time.\r\n                        for { let o := 0 } 1 {} {\r\n                            mstore(add(result, o), mload(add(replacement, o)))\r\n                            o := add(o, 0x20)\r\n                            if iszero(lt(o, replacementLength)) { break }\r\n                        }\r\n                        result := add(result, replacementLength)\r\n                        subject := add(subject, searchLength)\r\n                        if searchLength {\r\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                            continue\r\n                        }\r\n                    }\r\n                    mstore(result, t)\r\n                    result := add(result, 1)\r\n                    subject := add(subject, 1)\r\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                }\r\n            }\r\n\r\n            let resultRemainder := result\r\n            result := add(mload(0x40), 0x20)\r\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\r\n            // Copy the rest of the string one word at a time.\r\n            for {} lt(subject, subjectEnd) {} {\r\n                mstore(resultRemainder, mload(subject))\r\n                resultRemainder := add(resultRemainder, 0x20)\r\n                subject := add(subject, 0x20)\r\n            }\r\n            result := sub(result, 0x20)\r\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\r\n            mstore(last, 0)\r\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\r\n            mstore(result, k) // Store the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from left to right, starting from `from`.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function indexOf(string memory subject, string memory search, uint256 from)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for { let subjectLength := mload(subject) } 1 {} {\r\n                if iszero(mload(search)) {\r\n                    if iszero(gt(from, subjectLength)) {\r\n                        result := from\r\n                        break\r\n                    }\r\n                    result := subjectLength\r\n                    break\r\n                }\r\n                let searchLength := mload(search)\r\n                let subjectStart := add(subject, 0x20)\r\n\r\n                result := not(0) // Initialize to `NOT_FOUND`.\r\n\r\n                subject := add(subjectStart, from)\r\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\r\n\r\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\r\n                let s := mload(add(search, 0x20))\r\n\r\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\r\n\r\n                if iszero(lt(searchLength, 0x20)) {\r\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\r\n                        if iszero(shr(m, xor(mload(subject), s))) {\r\n                            if eq(keccak256(subject, searchLength), h) {\r\n                                result := sub(subject, subjectStart)\r\n                                break\r\n                            }\r\n                        }\r\n                        subject := add(subject, 1)\r\n                        if iszero(lt(subject, end)) { break }\r\n                    }\r\n                    break\r\n                }\r\n                for {} 1 {} {\r\n                    if iszero(shr(m, xor(mload(subject), s))) {\r\n                        result := sub(subject, subjectStart)\r\n                        break\r\n                    }\r\n                    subject := add(subject, 1)\r\n                    if iszero(lt(subject, end)) { break }\r\n                }\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from left to right.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function indexOf(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        result = indexOf(subject, search, 0);\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from right to left, starting from `from`.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for {} 1 {} {\r\n                result := not(0) // Initialize to `NOT_FOUND`.\r\n                let searchLength := mload(search)\r\n                if gt(searchLength, mload(subject)) { break }\r\n                let w := result\r\n\r\n                let fromMax := sub(mload(subject), searchLength)\r\n                if iszero(gt(fromMax, from)) { from := fromMax }\r\n\r\n                let end := add(add(subject, 0x20), w)\r\n                subject := add(add(subject, 0x20), from)\r\n                if iszero(gt(subject, end)) { break }\r\n                // As this function is not too often used,\r\n                // we shall simply use keccak256 for smaller bytecode size.\r\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\r\n                    if eq(keccak256(subject, searchLength), h) {\r\n                        result := sub(subject, add(end, 1))\r\n                        break\r\n                    }\r\n                    subject := add(subject, w) // `sub(subject, 1)`.\r\n                    if iszero(gt(subject, end)) { break }\r\n                }\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from right to left.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function lastIndexOf(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\r\n    }\r\n\r\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\r\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\r\n        return indexOf(subject, search) != NOT_FOUND;\r\n    }\r\n\r\n    /// @dev Returns whether `subject` starts with `search`.\r\n    function startsWith(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (bool result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let searchLength := mload(search)\r\n            // Just using keccak256 directly is actually cheaper.\r\n            // forgefmt: disable-next-item\r\n            result := and(\r\n                iszero(gt(searchLength, mload(subject))),\r\n                eq(\r\n                    keccak256(add(subject, 0x20), searchLength),\r\n                    keccak256(add(search, 0x20), searchLength)\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether `subject` ends with `search`.\r\n    function endsWith(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (bool result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let searchLength := mload(search)\r\n            let subjectLength := mload(subject)\r\n            // Whether `search` is not longer than `subject`.\r\n            let withinRange := iszero(gt(searchLength, subjectLength))\r\n            // Just using keccak256 directly is actually cheaper.\r\n            // forgefmt: disable-next-item\r\n            result := and(\r\n                withinRange,\r\n                eq(\r\n                    keccak256(\r\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\r\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\r\n                        searchLength\r\n                    ),\r\n                    keccak256(add(search, 0x20), searchLength)\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `subject` repeated `times`.\r\n    function repeat(string memory subject, uint256 times)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            if iszero(or(iszero(times), iszero(subjectLength))) {\r\n                subject := add(subject, 0x20)\r\n                result := mload(0x40)\r\n                let output := add(result, 0x20)\r\n                for {} 1 {} {\r\n                    // Copy the `subject` one word at a time.\r\n                    for { let o := 0 } 1 {} {\r\n                        mstore(add(output, o), mload(add(subject, o)))\r\n                        o := add(o, 0x20)\r\n                        if iszero(lt(o, subjectLength)) { break }\r\n                    }\r\n                    output := add(output, subjectLength)\r\n                    times := sub(times, 1)\r\n                    if iszero(times) { break }\r\n                }\r\n                mstore(output, 0) // Zeroize the slot after the string.\r\n                let resultLength := sub(output, add(result, 0x20))\r\n                mstore(result, resultLength) // Store the length.\r\n                // Allocate the memory.\r\n                mstore(0x40, add(result, add(resultLength, 0x20)))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\r\n    /// `start` and `end` are byte offsets.\r\n    function slice(string memory subject, uint256 start, uint256 end)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\r\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\r\n            if lt(start, end) {\r\n                result := mload(0x40)\r\n                let resultLength := sub(end, start)\r\n                mstore(result, resultLength)\r\n                subject := add(subject, start)\r\n                let w := not(0x1f)\r\n                // Copy the `subject` one word at a time, backwards.\r\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\r\n                    mstore(add(result, o), mload(add(subject, o)))\r\n                    o := add(o, w) // `sub(o, 0x20)`.\r\n                    if iszero(o) { break }\r\n                }\r\n                // Zeroize the slot after the string.\r\n                mstore(add(add(result, 0x20), resultLength), 0)\r\n                // Allocate memory for the length and the bytes,\r\n                // rounded up to a multiple of 32.\r\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\r\n    /// `start` is a byte offset.\r\n    function slice(string memory subject, uint256 start)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        result = slice(subject, start, uint256(int256(-1)));\r\n    }\r\n\r\n    /// @dev Returns all the indices of `search` in `subject`.\r\n    /// The indices are byte offsets.\r\n    function indicesOf(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (uint256[] memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            let searchLength := mload(search)\r\n\r\n            if iszero(gt(searchLength, subjectLength)) {\r\n                subject := add(subject, 0x20)\r\n                search := add(search, 0x20)\r\n                result := add(mload(0x40), 0x20)\r\n\r\n                let subjectStart := subject\r\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\r\n                let h := 0\r\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\r\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\r\n                let s := mload(search)\r\n                for {} 1 {} {\r\n                    let t := mload(subject)\r\n                    // Whether the first `searchLength % 32` bytes of\r\n                    // `subject` and `search` matches.\r\n                    if iszero(shr(m, xor(t, s))) {\r\n                        if h {\r\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\r\n                                subject := add(subject, 1)\r\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                                continue\r\n                            }\r\n                        }\r\n                        // Append to `result`.\r\n                        mstore(result, sub(subject, subjectStart))\r\n                        result := add(result, 0x20)\r\n                        // Advance `subject` by `searchLength`.\r\n                        subject := add(subject, searchLength)\r\n                        if searchLength {\r\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                            continue\r\n                        }\r\n                    }\r\n                    subject := add(subject, 1)\r\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                }\r\n                let resultEnd := result\r\n                // Assign `result` to the free memory pointer.\r\n                result := mload(0x40)\r\n                // Store the length of `result`.\r\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\r\n                // Allocate memory for result.\r\n                // We allocate one more word, so this array can be recycled for {split}.\r\n                mstore(0x40, add(resultEnd, 0x20))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\r\n    function split(string memory subject, string memory delimiter)\r\n        internal\r\n        pure\r\n        returns (string[] memory result)\r\n    {\r\n        uint256[] memory indices = indicesOf(subject, delimiter);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let w := not(0x1f)\r\n            let indexPtr := add(indices, 0x20)\r\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\r\n            mstore(add(indicesEnd, w), mload(subject))\r\n            mstore(indices, add(mload(indices), 1))\r\n            let prevIndex := 0\r\n            for {} 1 {} {\r\n                let index := mload(indexPtr)\r\n                mstore(indexPtr, 0x60)\r\n                if iszero(eq(index, prevIndex)) {\r\n                    let element := mload(0x40)\r\n                    let elementLength := sub(index, prevIndex)\r\n                    mstore(element, elementLength)\r\n                    // Copy the `subject` one word at a time, backwards.\r\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\r\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\r\n                        o := add(o, w) // `sub(o, 0x20)`.\r\n                        if iszero(o) { break }\r\n                    }\r\n                    // Zeroize the slot after the string.\r\n                    mstore(add(add(element, 0x20), elementLength), 0)\r\n                    // Allocate memory for the length and the bytes,\r\n                    // rounded up to a multiple of 32.\r\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\r\n                    // Store the `element` into the array.\r\n                    mstore(indexPtr, element)\r\n                }\r\n                prevIndex := add(index, mload(delimiter))\r\n                indexPtr := add(indexPtr, 0x20)\r\n                if iszero(lt(indexPtr, indicesEnd)) { break }\r\n            }\r\n            result := indices\r\n            if iszero(mload(delimiter)) {\r\n                result := add(indices, 0x20)\r\n                mstore(result, sub(mload(indices), 2))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a concatenated string of `a` and `b`.\r\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\r\n    function concat(string memory a, string memory b)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let w := not(0x1f)\r\n            result := mload(0x40)\r\n            let aLength := mload(a)\r\n            // Copy `a` one word at a time, backwards.\r\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\r\n                mstore(add(result, o), mload(add(a, o)))\r\n                o := add(o, w) // `sub(o, 0x20)`.\r\n                if iszero(o) { break }\r\n            }\r\n            let bLength := mload(b)\r\n            let output := add(result, aLength)\r\n            // Copy `b` one word at a time, backwards.\r\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\r\n                mstore(add(output, o), mload(add(b, o)))\r\n                o := add(o, w) // `sub(o, 0x20)`.\r\n                if iszero(o) { break }\r\n            }\r\n            let totalLength := add(aLength, bLength)\r\n            let last := add(add(result, 0x20), totalLength)\r\n            // Zeroize the slot after the string.\r\n            mstore(last, 0)\r\n            // Stores the length.\r\n            mstore(result, totalLength)\r\n            // Allocate memory for the length and the bytes,\r\n            // rounded up to a multiple of 32.\r\n            mstore(0x40, and(add(last, 0x1f), w))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\r\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\r\n    function toCase(string memory subject, bool toUpper)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let length := mload(subject)\r\n            if length {\r\n                result := add(mload(0x40), 0x20)\r\n                subject := add(subject, 1)\r\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\r\n                let w := not(0)\r\n                for { let o := length } 1 {} {\r\n                    o := add(o, w)\r\n                    let b := and(0xff, mload(add(subject, o)))\r\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\r\n                    if iszero(o) { break }\r\n                }\r\n                result := mload(0x40)\r\n                mstore(result, length) // Store the length.\r\n                let last := add(add(result, 0x20), length)\r\n                mstore(last, 0) // Zeroize the slot after the string.\r\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a string from a small bytes32 string.\r\n    /// `smallString` must be null terminated, or behavior will be undefined.\r\n    function fromSmallString(bytes32 smallString) internal pure returns (string memory result) {\r\n        if (smallString == bytes32(0)) return result;\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := mload(0x40)\r\n            let n := 0\r\n            for {} 1 {} {\r\n                n := add(n, 1)\r\n                if iszero(byte(n, smallString)) { break } // Scan for '\\0'.\r\n            }\r\n            mstore(result, n)\r\n            let o := add(result, 0x20)\r\n            mstore(o, smallString)\r\n            mstore(add(o, n), 0)\r\n            mstore(0x40, add(result, 0x40))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a lowercased copy of the string.\r\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\r\n    function lower(string memory subject) internal pure returns (string memory result) {\r\n        result = toCase(subject, false);\r\n    }\r\n\r\n    /// @dev Returns an UPPERCASED copy of the string.\r\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\r\n    function upper(string memory subject) internal pure returns (string memory result) {\r\n        result = toCase(subject, true);\r\n    }\r\n\r\n    /// @dev Escapes the string to be used within HTML tags.\r\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let end := add(s, mload(s))\r\n            result := add(mload(0x40), 0x20)\r\n            // Store the bytes of the packed offsets and strides into the scratch space.\r\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\r\n            mstore(0x1f, 0x900094)\r\n            mstore(0x08, 0xc0000000a6ab)\r\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\r\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\r\n            for {} iszero(eq(s, end)) {} {\r\n                s := add(s, 1)\r\n                let c := and(mload(s), 0xff)\r\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\r\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\r\n                    mstore8(result, c)\r\n                    result := add(result, 1)\r\n                    continue\r\n                }\r\n                let t := shr(248, mload(c))\r\n                mstore(result, mload(and(t, 0x1f)))\r\n                result := add(result, shr(5, t))\r\n            }\r\n            let last := result\r\n            mstore(last, 0) // Zeroize the slot after the string.\r\n            result := mload(0x40)\r\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\r\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\r\n        }\r\n    }\r\n\r\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\r\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\r\n    function escapeJSON(string memory s, bool addDoubleQuotes)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let end := add(s, mload(s))\r\n            result := add(mload(0x40), 0x20)\r\n            if addDoubleQuotes {\r\n                mstore8(result, 34)\r\n                result := add(1, result)\r\n            }\r\n            // Store \"\\\\u0000\" in scratch space.\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\r\n            // into the scratch space.\r\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\r\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\r\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\r\n            for {} iszero(eq(s, end)) {} {\r\n                s := add(s, 1)\r\n                let c := and(mload(s), 0xff)\r\n                if iszero(lt(c, 0x20)) {\r\n                    if iszero(and(shl(c, 1), e)) {\r\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\r\n                        mstore8(result, c)\r\n                        result := add(result, 1)\r\n                        continue\r\n                    }\r\n                    mstore8(result, 0x5c) // \"\\\\\".\r\n                    mstore8(add(result, 1), c)\r\n                    result := add(result, 2)\r\n                    continue\r\n                }\r\n                if iszero(and(shl(c, 1), 0x3700)) {\r\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\r\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\r\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\r\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\r\n                    result := add(result, 6)\r\n                    continue\r\n                }\r\n                mstore8(result, 0x5c) // \"\\\\\".\r\n                mstore8(add(result, 1), mload(add(c, 8)))\r\n                result := add(result, 2)\r\n            }\r\n            if addDoubleQuotes {\r\n                mstore8(result, 34)\r\n                result := add(1, result)\r\n            }\r\n            let last := result\r\n            mstore(last, 0) // Zeroize the slot after the string.\r\n            result := mload(0x40)\r\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\r\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\r\n        }\r\n    }\r\n\r\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\r\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\r\n        result = escapeJSON(s, false);\r\n    }\r\n\r\n    /// @dev Returns whether `a` equals `b`.\r\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether `a` equals `b`. For small strings up to 32 bytes.\r\n    /// `b` must be null terminated, or behavior will be undefined.\r\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // These should be evaluated on compile time, as far as possible.\r\n            let x := and(b, add(not(b), 1))\r\n            let r := or(shl(8, iszero(b)), shl(7, iszero(iszero(shr(128, x)))))\r\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\r\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\r\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\r\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\r\n            result := gt(eq(mload(a), sub(32, shr(3, r))), shr(r, xor(b, mload(add(a, 0x20)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Packs a single string with its length into a single word.\r\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\r\n    function packOne(string memory a) internal pure returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We don't need to zero right pad the string,\r\n            // since this is our own custom non-standard packing scheme.\r\n            result :=\r\n                mul(\r\n                    // Load the length and the bytes.\r\n                    mload(add(a, 0x1f)),\r\n                    // `length != 0 && length < 32`. Abuses underflow.\r\n                    // Assumes that the length is valid and within the block gas limit.\r\n                    lt(sub(mload(a), 1), 0x1f)\r\n                )\r\n        }\r\n    }\r\n\r\n    /// @dev Unpacks a string packed using {packOne}.\r\n    /// Returns the empty string if `packed` is `bytes32(0)`.\r\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\r\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Grab the free memory pointer.\r\n            result := mload(0x40)\r\n            // Allocate 2 words (1 for the length, 1 for the bytes).\r\n            mstore(0x40, add(result, 0x40))\r\n            // Zeroize the length slot.\r\n            mstore(result, 0)\r\n            // Store the length and bytes.\r\n            mstore(add(result, 0x1f), packed)\r\n            // Right pad with zeroes.\r\n            mstore(add(add(result, 0x20), mload(result)), 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Packs two strings with their lengths into a single word.\r\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\r\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let aLength := mload(a)\r\n            // We don't need to zero right pad the strings,\r\n            // since this is our own custom non-standard packing scheme.\r\n            result :=\r\n                mul(\r\n                    // Load the length and the bytes of `a` and `b`.\r\n                    or(\r\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\r\n                        mload(sub(add(b, 0x1e), aLength))\r\n                    ),\r\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\r\n                    // Assumes that the lengths are valid and within the block gas limit.\r\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\r\n                )\r\n        }\r\n    }\r\n\r\n    /// @dev Unpacks strings packed using {packTwo}.\r\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\r\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\r\n    function unpackTwo(bytes32 packed)\r\n        internal\r\n        pure\r\n        returns (string memory resultA, string memory resultB)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Grab the free memory pointer.\r\n            resultA := mload(0x40)\r\n            resultB := add(resultA, 0x40)\r\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\r\n            mstore(0x40, add(resultB, 0x40))\r\n            // Zeroize the length slots.\r\n            mstore(resultA, 0)\r\n            mstore(resultB, 0)\r\n            // Store the lengths and bytes.\r\n            mstore(add(resultA, 0x1f), packed)\r\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\r\n            // Right pad with zeroes.\r\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\r\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Directly returns `a` without copying.\r\n    function directReturn(string memory a) internal pure {\r\n        assembly {\r\n            // Assumes that the string does not start from the scratch space.\r\n            let retStart := sub(a, 0x20)\r\n            let retSize := add(mload(a), 0x40)\r\n            // Right pad with zeroes. Just in case the string is produced\r\n            // by a method that doesn't zero right pad.\r\n            mstore(add(retStart, retSize), 0)\r\n            // Store the return offset.\r\n            mstore(retStart, 0x20)\r\n            // End the transaction, returning the string.\r\n            return(retStart, retSize)\r\n        }\r\n    }\r\n}\r\n"},"lib/solady/src/utils/SafeTransferLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\n/// - For ERC20s, this implementation won't check that a token has code,\n///   responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for\n    /// the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x34, 0) // Store 0 for the `amount`.\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                mstore(0x34, amount) // Store back the original `amount`.\n                // Retry the approval, reverting upon failure.\n                if iszero(\n                    and(\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    )\n                ) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul(\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n}\n"},"lib/solady/src/utils/LibZip.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for compressing and decompressing bytes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibZip.sol)\n/// @author Calldata compression by clabby (https://github.com/clabby/op-kompressor)\n/// @author FastLZ by ariya (https://github.com/ariya/FastLZ)\n///\n/// @dev Note:\n/// The accompanying solady.js library includes implementations of\n/// FastLZ and calldata operations for convenience.\nlibrary LibZip {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     FAST LZ OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // LZ77 implementation based on FastLZ.\n    // Equivalent to level 1 compression and decompression at the following commit:\n    // https://github.com/ariya/FastLZ/commit/344eb4025f9ae866ebf7a2ec48850f7113a97a42\n    // Decompression is backwards compatible.\n\n    /// @dev Returns the compressed `data`.\n    function flzCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function ms8(d_, v_) -> _d {\n                mstore8(d_, v_)\n                _d := add(d_, 1)\n            }\n            function u24(p_) -> _u {\n                let w := mload(p_)\n                _u := or(shl(16, byte(2, w)), or(shl(8, byte(1, w)), byte(0, w)))\n            }\n            function cmp(p_, q_, e_) -> _l {\n                for { e_ := sub(e_, q_) } lt(_l, e_) { _l := add(_l, 1) } {\n                    e_ := mul(iszero(byte(0, xor(mload(add(p_, _l)), mload(add(q_, _l))))), e_)\n                }\n            }\n            function literals(runs_, src_, dest_) -> _o {\n                for { _o := dest_ } iszero(lt(runs_, 0x20)) { runs_ := sub(runs_, 0x20) } {\n                    mstore(ms8(_o, 31), mload(src_))\n                    _o := add(_o, 0x21)\n                    src_ := add(src_, 0x20)\n                }\n                if iszero(runs_) { leave }\n                mstore(ms8(_o, sub(runs_, 1)), mload(src_))\n                _o := add(1, add(_o, runs_))\n            }\n            function match(l_, d_, o_) -> _o {\n                for { d_ := sub(d_, 1) } iszero(lt(l_, 263)) { l_ := sub(l_, 262) } {\n                    o_ := ms8(ms8(ms8(o_, add(224, shr(8, d_))), 253), and(0xff, d_))\n                }\n                if iszero(lt(l_, 7)) {\n                    _o := ms8(ms8(ms8(o_, add(224, shr(8, d_))), sub(l_, 7)), and(0xff, d_))\n                    leave\n                }\n                _o := ms8(ms8(o_, add(shl(5, l_), shr(8, d_))), and(0xff, d_))\n            }\n            function setHash(i_, v_) {\n                let p := add(mload(0x40), shl(2, i_))\n                mstore(p, xor(mload(p), shl(224, xor(shr(224, mload(p)), v_))))\n            }\n            function getHash(i_) -> _h {\n                _h := shr(224, mload(add(mload(0x40), shl(2, i_))))\n            }\n            function hash(v_) -> _r {\n                _r := and(shr(19, mul(2654435769, v_)), 0x1fff)\n            }\n            function setNextHash(ip_, ipStart_) -> _ip {\n                setHash(hash(u24(ip_)), sub(ip_, ipStart_))\n                _ip := add(ip_, 1)\n            }\n            codecopy(mload(0x40), codesize(), 0x8000) // Zeroize the hashmap.\n            let op := add(mload(0x40), 0x8000)\n            let a := add(data, 0x20)\n            let ipStart := a\n            let ipLimit := sub(add(ipStart, mload(data)), 13)\n            for { let ip := add(2, a) } lt(ip, ipLimit) {} {\n                let r := 0\n                let d := 0\n                for {} 1 {} {\n                    let s := u24(ip)\n                    let h := hash(s)\n                    r := add(ipStart, getHash(h))\n                    setHash(h, sub(ip, ipStart))\n                    d := sub(ip, r)\n                    if iszero(lt(ip, ipLimit)) { break }\n                    ip := add(ip, 1)\n                    if iszero(gt(d, 0x1fff)) { if eq(s, u24(r)) { break } }\n                }\n                if iszero(lt(ip, ipLimit)) { break }\n                ip := sub(ip, 1)\n                if gt(ip, a) { op := literals(sub(ip, a), a, op) }\n                let l := cmp(add(r, 3), add(ip, 3), add(ipLimit, 9))\n                op := match(l, d, op)\n                ip := setNextHash(setNextHash(add(ip, l), ipStart), ipStart)\n                a := ip\n            }\n            op := literals(sub(add(ipStart, mload(data)), a), a, op)\n            result := mload(0x40)\n            let t := add(result, 0x8000)\n            let n := sub(op, t)\n            mstore(result, n) // Store the length.\n            // Copy the result to compact the memory, overwriting the hashmap.\n            let o := add(result, 0x20)\n            for { let i } lt(i, n) { i := add(i, 0x20) } { mstore(add(o, i), mload(add(t, i))) }\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the decompressed `data`.\n    function flzDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := 0\n            let end := add(add(data, 0x20), mload(data))\n            result := mload(0x40)\n            let op := add(result, 0x20)\n            for { data := add(data, 0x20) } lt(data, end) {} {\n                let w := mload(data)\n                let c := byte(0, w)\n                let t := shr(5, c)\n                if iszero(t) {\n                    mstore(add(op, n), mload(add(data, 1)))\n                    data := add(data, add(2, c))\n                    n := add(n, add(1, c))\n                    continue\n                }\n                let g := eq(t, 7)\n                let l := add(2, xor(t, mul(g, xor(t, add(7, byte(1, w))))))\n                for {\n                    let s := add(add(shl(8, and(0x1f, c)), byte(add(1, g), w)), 1)\n                    let r := add(op, sub(n, s))\n                    let o := add(op, n)\n                    let f := xor(s, mul(gt(s, 0x20), xor(s, 0x20)))\n                    let j := 0\n                } 1 {} {\n                    mstore(add(o, j), mload(add(r, j)))\n                    j := add(j, f)\n                    if iszero(lt(j, l)) { break }\n                }\n                data := add(data, add(2, g))\n                n := add(n, l)\n            }\n            mstore(result, n) // Store the length.\n            let o := add(add(result, 0x20), n)\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    CALLDATA OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Calldata compression and decompression using selective run length encoding:\n    // - Sequences of 0x00 (up to 128 consecutive).\n    // - Sequences of 0xff (up to 32 consecutive).\n    //\n    // A run length encoded block consists of two bytes:\n    // (0) 0x00\n    // (1) A control byte with the following bit layout:\n    //     - [7]     `0: 0x00, 1: 0xff`.\n    //     - [0..6]  `runLength - 1`.\n    //\n    // The first 4 bytes are bitwise negated so that the compressed calldata\n    // can be dispatched into the `fallback` and `receive` functions.\n\n    /// @dev Returns the compressed `data`.\n    function cdCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function rle(v_, o_, d_) -> _o, _d {\n                mstore(o_, shl(240, or(and(0xff, add(d_, 0xff)), and(0x80, v_))))\n                _o := add(o_, 2)\n            }\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let z := 0 // Number of consecutive 0x00.\n            let y := 0 // Number of consecutive 0xff.\n            for { let end := add(data, mload(data)) } iszero(eq(data, end)) {} {\n                data := add(data, 1)\n                let c := byte(31, mload(data))\n                if iszero(c) {\n                    if y { o, y := rle(0xff, o, y) }\n                    z := add(z, 1)\n                    if eq(z, 0x80) { o, z := rle(0x00, o, 0x80) }\n                    continue\n                }\n                if eq(c, 0xff) {\n                    if z { o, z := rle(0x00, o, z) }\n                    y := add(y, 1)\n                    if eq(y, 0x20) { o, y := rle(0xff, o, 0x20) }\n                    continue\n                }\n                if y { o, y := rle(0xff, o, y) }\n                if z { o, z := rle(0x00, o, z) }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            if y { o, y := rle(0xff, o, y) }\n            if z { o, z := rle(0x00, o, z) }\n            // Bitwise negate the first 4 bytes.\n            mstore(add(result, 4), not(mload(add(result, 4))))\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the decompressed `data`.\n    function cdDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(data) {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let s := add(data, 4)\n                let v := mload(s)\n                let end := add(data, mload(data))\n                mstore(s, not(v)) // Bitwise negate the first 4 bytes.\n                for {} lt(data, end) {} {\n                    data := add(data, 1)\n                    let c := byte(31, mload(data))\n                    if iszero(c) {\n                        data := add(data, 1)\n                        let d := byte(31, mload(data))\n                        // Fill with either 0xff or 0x00.\n                        mstore(o, not(0))\n                        if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                        o := add(o, add(and(d, 0x7f), 1))\n                        continue\n                    }\n                    mstore8(o, c)\n                    o := add(o, 1)\n                }\n                mstore(s, v) // Restore the first 4 bytes.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev To be called in the `receive` and `fallback` functions.\n    /// ```\n    ///     receive() external payable { LibZip.cdFallback(); }\n    ///     fallback() external payable { LibZip.cdFallback(); }\n    /// ```\n    /// For efficiency, this function will directly return the results, terminating the context.\n    /// If called internally, it must be called at the end of the function.\n    function cdFallback() internal {\n        assembly {\n            if iszero(calldatasize()) { return(calldatasize(), calldatasize()) }\n            let o := 0\n            let f := not(3) // For negating the first 4 bytes.\n            for { let i := 0 } lt(i, calldatasize()) {} {\n                let c := byte(0, xor(add(i, f), calldataload(i)))\n                i := add(i, 1)\n                if iszero(c) {\n                    let d := byte(0, xor(add(i, f), calldataload(i)))\n                    i := add(i, 1)\n                    // Fill with either 0xff or 0x00.\n                    mstore(o, not(0))\n                    if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                    o := add(o, add(and(d, 0x7f), 1))\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            let success := delegatecall(gas(), address(), 0x00, o, codesize(), 0x00)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(success) { revert(0x00, returndatasize()) }\n            return(0x00, returndatasize())\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"},"contracts/interfaces/IQuestOwnable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.19;\r\n\r\nimport {IOwnable} from \"./IOwnable.sol\";\r\nimport {IQuest} from \"./IQuest.sol\";\r\n\r\n// solhint-disable-next-line no-empty-blocks\r\ninterface IQuestOwnable is IQuest, IOwnable {}\r\n"},"contracts/interfaces/IQuest1155Ownable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.19;\r\n\r\nimport {IOwnable} from \"./IOwnable.sol\";\r\nimport {IQuest1155} from \"./IQuest1155.sol\";\r\n\r\n// solhint-disable-next-line no-empty-blocks\r\ninterface IQuest1155Ownable is IQuest1155, IOwnable {}\r\n"},"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"},"lib/solady/src/auth/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Simple single owner authorization mixin.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\r\n///\r\n/// @dev Note:\r\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\r\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\r\n///\r\n/// While the ownable portion follows\r\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\r\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\r\nabstract contract Ownable {\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev The caller is not authorized to call the function.\r\n    error Unauthorized();\r\n\r\n    /// @dev The `newOwner` cannot be the zero address.\r\n    error NewOwnerIsZeroAddress();\r\n\r\n    /// @dev The `pendingOwner` does not have a valid handover request.\r\n    error NoHandoverRequest();\r\n\r\n    /// @dev Cannot double-initialize.\r\n    error AlreadyInitialized();\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                           EVENTS                           */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\r\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\r\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\r\n    /// despite it not being as lightweight as a single argument event.\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /// @dev An ownership handover to `pendingOwner` has been requested.\r\n    event OwnershipHandoverRequested(address indexed pendingOwner);\r\n\r\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\r\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\r\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\r\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\r\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\r\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\r\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\r\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                          STORAGE                           */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev The owner slot is given by:\r\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\r\n    /// It is intentionally chosen to be a high value\r\n    /// to avoid collision with lower slots.\r\n    /// The choice of manual storage layout is to enable compatibility\r\n    /// with both regular and upgradeable contracts.\r\n    bytes32 internal constant _OWNER_SLOT =\r\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\r\n\r\n    /// The ownership handover slot of `newOwner` is given by:\r\n    /// ```\r\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\r\n    ///     let handoverSlot := keccak256(0x00, 0x20)\r\n    /// ```\r\n    /// It stores the expiry timestamp of the two-step ownership handover.\r\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                     INTERNAL FUNCTIONS                     */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\r\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\r\n\r\n    /// @dev Initializes the owner directly without authorization guard.\r\n    /// This function must be called upon initialization,\r\n    /// regardless of whether the contract is upgradeable or not.\r\n    /// This is to enable generalization to both regular and upgradeable contracts,\r\n    /// and to save gas in case the initial owner is not the caller.\r\n    /// For performance reasons, this function will not check if there\r\n    /// is an existing owner.\r\n    function _initializeOwner(address newOwner) internal virtual {\r\n        if (_guardInitializeOwner()) {\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let ownerSlot := _OWNER_SLOT\r\n                if sload(ownerSlot) {\r\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                // Clean the upper 96 bits.\r\n                newOwner := shr(96, shl(96, newOwner))\r\n                // Store the new value.\r\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\r\n                // Emit the {OwnershipTransferred} event.\r\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\r\n            }\r\n        } else {\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                // Clean the upper 96 bits.\r\n                newOwner := shr(96, shl(96, newOwner))\r\n                // Store the new value.\r\n                sstore(_OWNER_SLOT, newOwner)\r\n                // Emit the {OwnershipTransferred} event.\r\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Sets the owner directly without authorization guard.\r\n    function _setOwner(address newOwner) internal virtual {\r\n        if (_guardInitializeOwner()) {\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let ownerSlot := _OWNER_SLOT\r\n                // Clean the upper 96 bits.\r\n                newOwner := shr(96, shl(96, newOwner))\r\n                // Emit the {OwnershipTransferred} event.\r\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\r\n                // Store the new value.\r\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\r\n            }\r\n        } else {\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let ownerSlot := _OWNER_SLOT\r\n                // Clean the upper 96 bits.\r\n                newOwner := shr(96, shl(96, newOwner))\r\n                // Emit the {OwnershipTransferred} event.\r\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\r\n                // Store the new value.\r\n                sstore(ownerSlot, newOwner)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Throws if the sender is not the owner.\r\n    function _checkOwner() internal view virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // If the caller is not the stored owner, revert.\r\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\r\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\r\n    /// Override to return a different value if needed.\r\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\r\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\r\n        return 48 * 3600;\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\r\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(shl(96, newOwner)) {\r\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    /// @dev Allows the owner to renounce their ownership.\r\n    function renounceOwnership() public payable virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /// @dev Request a two-step ownership handover to the caller.\r\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\r\n    function requestOwnershipHandover() public payable virtual {\r\n        unchecked {\r\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                // Compute and set the handover slot to `expires`.\r\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n                mstore(0x00, caller())\r\n                sstore(keccak256(0x0c, 0x20), expires)\r\n                // Emit the {OwnershipHandoverRequested} event.\r\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\r\n    function cancelOwnershipHandover() public payable virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute and set the handover slot to 0.\r\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            sstore(keccak256(0x0c, 0x20), 0)\r\n            // Emit the {OwnershipHandoverCanceled} event.\r\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\r\n        }\r\n    }\r\n\r\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\r\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\r\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute and set the handover slot to 0.\r\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n            mstore(0x00, pendingOwner)\r\n            let handoverSlot := keccak256(0x0c, 0x20)\r\n            // If the handover does not exist, or has expired.\r\n            if gt(timestamp(), sload(handoverSlot)) {\r\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Set the handover slot to 0.\r\n            sstore(handoverSlot, 0)\r\n        }\r\n        _setOwner(pendingOwner);\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                   PUBLIC READ FUNCTIONS                    */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Returns the owner of the contract.\r\n    function owner() public view virtual returns (address result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := sload(_OWNER_SLOT)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\r\n    function ownershipHandoverExpiresAt(address pendingOwner)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the handover slot.\r\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n            mstore(0x00, pendingOwner)\r\n            // Load the handover slot.\r\n            result := sload(keccak256(0x0c, 0x20))\r\n        }\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                         MODIFIERS                          */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Marks a function as only callable by the owner.\r\n    modifier onlyOwner() virtual {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n}\r\n"},"lib/openzeppelin-contracts/contracts/utils/Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"contracts/interfaces/IOwnable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\ninterface IOwnable {\r\n    // Events\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n    event OwnershipHandoverRequested(address indexed pendingOwner);\r\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\r\n\r\n    // Update functions\r\n    function transferOwnership(address newOwner) external payable;\r\n    function renounceOwnership() external payable;\r\n    function requestOwnershipHandover() external payable;\r\n    function cancelOwnershipHandover() external payable;\r\n    function completeOwnershipHandover(address pendingOwner) external payable;\r\n\r\n    // Read functions\r\n    function owner() external view returns (address);\r\n    function ownershipHandoverExpiresAt(address pendingOwner) external view returns (uint256);\r\n}\r\n"},"contracts/interfaces/IQuest.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.19;\r\n\r\ninterface IQuest {\r\n    event Queued(uint256 timestamp);\r\n    event ProtocolFeeDistributed(string questId, address rewardToken, address protocolOwner, uint256 feeAmountToProtocolOwner, address questOwner, uint256 feeAmountToQuestOwner);\r\n\r\n    error AlreadyClaimed();\r\n    error AlreadyWithdrawn();\r\n    error AmountExceedsBalance();\r\n    error ClaimWindowNotStarted();\r\n    error EndTimeInPast();\r\n    error EndTimeLessThanOrEqualToStartTime();\r\n    error InvalidRefundToken();\r\n    error MustImplementInChild();\r\n    error NotQuestFactory();\r\n    error NoWithdrawDuringClaim();\r\n    error NotStarted();\r\n    error TotalAmountExceedsBalance();\r\n    error AuthOwnerRecipient();\r\n    error AddressNotSigned();\r\n    error InvalidClaimFee();\r\n    error OverMaxAllowedToMint();\r\n    error AddressAlreadyMinted();\r\n    error QuestEnded();\r\n\r\n    function initialize(\r\n        address rewardTokenAddress_,\r\n        uint256 endTime_,\r\n        uint256 startTime_,\r\n        uint256 totalParticipants_,\r\n        uint256 rewardAmountInWei_,\r\n        string memory questId_,\r\n        uint16 questFee_,\r\n        address protocolFeeRecipient_\r\n    ) external;\r\n    function getRewardAmount() external view returns (uint256);\r\n    function getRewardToken() external view returns (address);\r\n    function queued() external view returns (bool);\r\n    function startTime() external view returns (uint256);\r\n    function endTime() external view returns (uint256);\r\n    function singleClaim(address account) external;\r\n    function rewardToken() external view returns (address);\r\n    function rewardAmountInWei() external view returns (uint256);\r\n    function totalTransferAmount() external view returns (uint256);\r\n    function questFee() external view returns (uint16);\r\n    function totalParticipants() external view returns (uint256);\r\n    function hasWithdrawn() external view returns (bool);\r\n    function questId() external view returns (string memory);\r\n}\r\n"},"contracts/interfaces/IQuest1155.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.19;\r\n\r\ninterface IQuest1155 {\r\n    // Structs\r\n    struct FactoryQuest {\r\n        mapping(address => bool) addressMinted;\r\n        address questAddress;\r\n        uint256 totalParticipants;\r\n        uint256 numberMinted;\r\n        string questType;\r\n        address questCreator;\r\n        address mintFeeRecipient;\r\n    }\r\n\r\n    // Events\r\n    event Queued(uint256 timestamp);\r\n\r\n    event QuestClaimedData(\r\n        address indexed recipient,\r\n        address indexed referrer,\r\n        string extraData\r\n    );\r\n\r\n    // Errors\r\n    error EndTimeInPast();\r\n    error EndTimeLessThanOrEqualToStartTime();\r\n    error InsufficientTokenBalance();\r\n    error InsufficientETHBalance();\r\n    error NotStarted();\r\n    error NotEnded();\r\n    error NotQueued();\r\n    error NotQuestFactory();\r\n    error QuestEnded();\r\n    error AlreadyWithdrawn();\r\n    error AddressNotSigned();\r\n    error InvalidClaimFee();\r\n    error AddressAlreadyMinted();\r\n    error OverMaxAllowedToMint();\r\n\r\n    // Initializer/Contstructor Function\r\n    function initialize(\r\n        address rewardTokenAddress_,\r\n        uint256 endTime_,\r\n        uint256 startTime_,\r\n        uint256 totalParticipants_,\r\n        uint256 tokenId_,\r\n        address protocolFeeRecipient_,\r\n        string memory questId_\r\n    ) external;\r\n\r\n    // Read Functions\r\n    function endTime() external view returns (uint256);\r\n    function hasWithdrawn() external view returns (bool);\r\n\r\n    function maxProtocolReward() external view returns (uint256);\r\n    function questFee() external view returns (uint256);\r\n    function queued() external view returns (bool);\r\n    function startTime() external view returns (uint256);\r\n    function tokenId() external view returns (uint256);\r\n    function rewardToken() external view returns (address);\r\n\r\n    // Update Functions\r\n    function pause() external;\r\n    function queue() external;\r\n    function singleClaim(address account_) external;\r\n    function unPause() external;\r\n    function withdrawRemainingTokens() external;\r\n    }\r\n"},"lib/openzeppelin-contracts/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"}},"settings":{"remappings":["ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/","openzeppelin/=lib/openzeppelin-contracts/contracts/","solady/=lib/solady/src/"],"optimizer":{"enabled":true,"runs":1000},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata","storageLayout"]}},"evmVersion":"paris","viaIR":true,"libraries":{}}}
